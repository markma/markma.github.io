<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[matlab cpp混编]]></title>
      <url>http://markma.tk/posts/Matlab/matlab%20cpp%E6%B7%B7%E7%BC%96/</url>
      <content type="html"><![CDATA[<p>matlab中集成许多易用的算法，这些算法不仅仅能运行在matlab环境下，经过编译我们写好的matlab脚本甚至可以运行于C++环境。这可以大大缩短开发周期，但可能一定程度降低程序性能（相对于纯C++程序而言）。<br><a id="more"></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先确保装有C++编译器，matlab。并且要保证C++编译器与matlab有着相同的位数（都为X64或X86）。</p>
<h3 id="配置matlab-C-编译环境"><a href="#配置matlab-C-编译环境" class="headerlink" title="配置matlab C++编译环境"></a>配置matlab C++编译环境</h3><p>在matlab中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;mex -setup</div></pre></td></tr></table></figure></p>
<p>配置C语言编译器<br><img src="http://i.imgur.com/oXs9CwX.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;mbuild -setup</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/byopBgA.png" alt=""><br>到此matlab c语言编译环境设置完成。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>配置好环境后，下面以一个绘图实例详细讲解如何生成和使用matlab脚本的动态链接库。</p>
<figure class="highlight matlab"><figcaption><span>mplot.m</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span><span class="params">[]</span> =<span class="title">mplot</span><span class="params">(x,y)</span></span></div><div class="line">plot(x,y)</div></pre></td></tr></table></figure>
<h3 id="生成动态链接库"><a href="#生成动态链接库" class="headerlink" title="生成动态链接库"></a>生成动态链接库</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>命令行输入 <code>&gt;&gt; deploytool</code> 打开开发工具,-&gt;Library Compiler选择C++ shared library和对应的matlab脚本文件。<br><img src="http://i.imgur.com/eW2gp6h.png" alt=""><br><img src="http://i.imgur.com/4jW74OI.png" alt=""><br>编译完成后即生成下面的文件夹。<br><img src="http://i.imgur.com/5YC8N4u.png" alt=""><br>下面的文件即为cpp程序中即将用到的动态链接库。<br><img src="http://i.imgur.com/lNv2rQO.png" alt=""></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>命令行执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mcc -l mplot.m</div></pre></td></tr></table></figure></p>
<p>同样可以生成动态链接库。</p>
<h3 id="动态链接库调用"><a href="#动态链接库调用" class="headerlink" title="动态链接库调用"></a>动态链接库调用</h3><p>如果调用不成功，请检查运行环境，比如编译器是否为win32,或者win64，要与matlab一致。 其次是否安装matlab runtime（matlab中命令行执行<code>&gt;&gt;mcrinstaller</code>）。</p>
<p>运行环境搞定后，需要将matlab中的运行库提取出来，或者直接包含到cpp工程中。</p>
<p>下面我们使用qt creator IDE为例介绍其使用。</p>
<h4 id="提取并配置matlab-VC运行库"><a href="#提取并配置matlab-VC运行库" class="headerlink" title="提取并配置matlab VC运行库"></a>提取并配置matlab VC运行库</h4><p>在matlab安装目录下\Matlab2015_x64\extern文件夹内拷贝inlcude和lib（或者使用windows的环境变量包含上述头文件）。<br>在QT工程配置文件中包含拷贝出来的include目录，并添加lib文件夹下的链接库。可以通过配置.pri文件实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line">LIBS += -L$$PWD \</div><div class="line">-lgpu\</div><div class="line">-llibcovrt\</div><div class="line">-llibemlrt\</div><div class="line">-llibeng\</div><div class="line">-llibfixedpoint\</div><div class="line">-llibmat\</div><div class="line">-llibmex\</div><div class="line">-llibmwblas\</div><div class="line">-llibmwblascompat32\</div><div class="line">-llibmwboxfilter\</div><div class="line">-llibmwboxfilter3\</div><div class="line">-llibmwbwdistEDT\</div><div class="line">-llibmwbwdistEDT_tbb\</div><div class="line">-llibmwbwdistEDTFT\</div><div class="line">-llibmwbwdistEDTFT_tbb\</div><div class="line">-llibmwbwlookup\</div><div class="line">-llibmwbwlookup_tbb\</div><div class="line">-llibmwbwpackc\</div><div class="line">-llibmwbwpackctbb\</div><div class="line">-llibmwbwunpackc\</div><div class="line">-llibmwbwunpackctbb\</div><div class="line">-llibmwcannythresholding_tbb\</div><div class="line">-llibmwcascadeClassifier\</div><div class="line">-llibmwcgir_construct\</div><div class="line">-llibmwcgxert\</div><div class="line">-llibmwcoder_connectivity_comm\</div><div class="line">-llibmwcoder_connectivity_memunit\</div><div class="line">-llibmwcoder_ParamTuningTgtAppSvc\</div><div class="line">-llibmwcoder_target_services\</div><div class="line">-llibmwcoder_ToAsyncQueueTgtAppSvc\</div><div class="line">-llibmwcoderassumptionsapp\</div><div class="line">-llibmwcoderprofile\</div><div class="line">-llibmwComputeMetric\</div><div class="line">-llibmwddist\</div><div class="line">-llibmwdetectBRISK\</div><div class="line">-llibmwdetectFAST\</div><div class="line">-llibmwdetectMser\</div><div class="line">-llibmwdisparityBM\</div><div class="line">-llibmwdisparitySGBM\</div><div class="line">-llibmwedgethinning_tbb\</div><div class="line">-llibmwextractBRISK\</div><div class="line">-llibmwextractFreak\</div><div class="line">-llibmwextractSurf\</div><div class="line">-llibmwfastHessianDetector\</div><div class="line">-llibmwfilcommon\</div><div class="line">-llibmwforegroundDetector\</div><div class="line">-llibmwgetnumcores\</div><div class="line">-llibmwgrayto16\</div><div class="line">-llibmwgrayto8\</div><div class="line">-llibmwgrayxform\</div><div class="line">-llibmwgrayxform_tbb\</div><div class="line">-llibmwHOGDescriptor\</div><div class="line">-llibmwimfilter\</div><div class="line">-llibmwimlincomb\</div><div class="line">-llibmwimlincomb_tbb\</div><div class="line">-llibmwimreconstruct\</div><div class="line">-llibmwimregionalmax\</div><div class="line">-llibmwint16touint16\</div><div class="line">-llibmwint32touint32\</div><div class="line">-llibmwint8touint8\</div><div class="line">-llibmwintlut\</div><div class="line">-llibmwintluttbb\</div><div class="line">-llibmwippfilter\</div><div class="line">-llibmwippgeotrans\</div><div class="line">-llibmwippmedianfilter\</div><div class="line">-llibmwippreconstruct\</div><div class="line">-llibmwlapack\</div><div class="line">-llibmwmatchFeatures\</div><div class="line">-llibmwmathutil\</div><div class="line">-llibmwmorphop_binary\</div><div class="line">-llibmwmorphop_binary_tbb\</div><div class="line">-llibmwmorphop_flat\</div><div class="line">-llibmwmorphop_flat_tbb\</div><div class="line">-llibmwmorphop_ipp\</div><div class="line">-llibmwmorphop_nonflat\</div><div class="line">-llibmwmorphop_nonflat_tbb\</div><div class="line">-llibmwmorphop_packed\</div><div class="line">-llibmwocvgpumex\</div><div class="line">-llibmwocvmex\</div><div class="line">-llibmwopticalFlowFarneback\</div><div class="line">-llibmwopticalFlowHSCore\</div><div class="line">-llibmwopticalFlowLKCore\</div><div class="line">-llibmwopticalFlowLKDoGCore\</div><div class="line">-llibmwordfilt2\</div><div class="line">-llibmwpointTracker\</div><div class="line">-llibmwremap\</div><div class="line">-llibmwremaptbb\</div><div class="line">-llibmwrtiostreamutils\</div><div class="line">-llibmwservices\</div><div class="line">-llibmwsigstream\</div><div class="line">-llibmwsimulink\</div><div class="line">-llibmwsl_AsyncioQueue\</div><div class="line">-llibmwsl_fileio\</div><div class="line">-llibmwsl_iofile\</div><div class="line">-llibmwsl_log_load_blocks\</div><div class="line">-llibmwsl_sfcn_cov_bridge\</div><div class="line">-llibmwsl_solver_rtw\</div><div class="line">-llibmwslexec_parallel\</div><div class="line">-llibmwslexec_simbridge\</div><div class="line">-llibmwtbbhist\</div><div class="line">-llibmwuint16toint16\</div><div class="line">-llibmwxilcomms\</div><div class="line">-llibmwxilcomms_rtiostream\</div><div class="line">-llibmwxilservice\</div><div class="line">-llibmwxilutils\</div><div class="line">-llibmwxilutils_sl\</div><div class="line">-llibmx\</div><div class="line">-llibut\</div><div class="line">-lmclbase\</div><div class="line">-lmclcommain\</div><div class="line">-lmclmcr\</div><div class="line">-lmclmcrrt\</div><div class="line">-lmclxlmain\</div><div class="line">-lne_mli\</div><div class="line">-lne_rtl\</div><div class="line">-locrutils\</div><div class="line">-lphysmod_common_external_library_kernel\</div><div class="line">-lphysmod_common_foundation_core_util\</div><div class="line">-lrtwcg\</div><div class="line">-lsf_runtime\</div><div class="line">-lSimulinkBlock\</div><div class="line">-lsl_services</div></pre></td></tr></table></figure></p>
<h4 id="配置mplot-VC运行库"><a href="#配置mplot-VC运行库" class="headerlink" title="配置mplot VC运行库"></a>配置mplot VC运行库</h4><p>同样额mplot的动态链接库也要添加进工程。</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>在main函数中添加下属语句，对链接库初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 初始化程序</span></div><div class="line"><span class="keyword">if</span>( ! mclInitializeApplication(<span class="literal">NULL</span>,<span class="number">0</span>) )</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not initialize the application.n"</span>&lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize the application.n"</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 初始化库</span></div><div class="line"><span class="keyword">if</span> (! mplotInitialize() )</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">"Could not initialize the library.n"</span>&lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Could not initialize the library.n"</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>matlab中数据都以矩阵的形式来表示，即便是在cpp中也是如此。matlab提供了Cpp数据接口mwArray，具体使用方法见<a href="http://cn.mathworks.com/help/compiler_sdk/cxx/mwarray.html?searchHighlight=mwArray&amp;s_tid=doc_srchtitle" target="_blank" rel="external">官方说明</a>。下面仅以一个简单例子进行介绍。<br>首先将所需的数据保存值mxDouble数组，然后实例化mwArray，并将数据链接到mwArray。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mxDouble x[]=&#123;</div><div class="line">    <span class="number">0</span>,<span class="number">0.157079632679490</span>,<span class="number">0.314159265358979</span>,<span class="number">0.471238898038469</span>,<span class="number">0.628318530717959</span>,<span class="number">0.785398163397448</span>,<span class="number">0.942477796076938</span>,<span class="number">1.09955742875643</span>,<span class="number">1.25663706143592</span>,<span class="number">1.41371669411541</span>,<span class="number">1.57079632679490</span>,<span class="number">1.72787595947439</span>,<span class="number">1.88495559215388</span>,<span class="number">2.04203522483337</span>,<span class="number">2.19911485751286</span>,<span class="number">2.35619449019235</span>,<span class="number">2.51327412287183</span>,<span class="number">2.67035375555132</span>,<span class="number">2.82743338823081</span>,<span class="number">2.98451302091030</span>,<span class="number">3.14159265358979</span>,<span class="number">3.29867228626928</span>,<span class="number">3.45575191894877</span>,<span class="number">3.61283155162826</span>,<span class="number">3.76991118430775</span>,<span class="number">3.92699081698724</span>,<span class="number">4.08407044966673</span>,<span class="number">4.24115008234622</span>,<span class="number">4.39822971502571</span>,<span class="number">4.55530934770520</span>,<span class="number">4.71238898038469</span>,<span class="number">4.86946861306418</span>,<span class="number">5.02654824574367</span>,<span class="number">5.18362787842316</span>,<span class="number">5.34070751110265</span>,<span class="number">5.49778714378214</span>,<span class="number">5.65486677646163</span>,<span class="number">5.81194640914112</span>,<span class="number">5.96902604182061</span>,<span class="number">6.12610567450010</span>,<span class="number">6.28318530717959</span></div><div class="line">&#125;;</div><div class="line">mxDouble y[]=&#123;</div><div class="line">    <span class="number">2</span>,<span class="number">-0.725324972339547</span>,<span class="number">-1.18317568280710</span>,<span class="number">1.47807570185109</span>,<span class="number">-0.0609006857112387</span>,<span class="number">-1.21904391609666</span>,<span class="number">0.936250913105442</span>,<span class="number">0.362752647593856</span>,<span class="number">-1.06326728866211</span>,<span class="number">0.461192845316532</span>,<span class="number">0.574191813840279</span>,<span class="number">-0.810627669650712</span>,<span class="number">0.0972434975400799</span>,<span class="number">0.622258451229734</span>,<span class="number">-0.534447387607577</span>,<span class="number">-0.144156436564858</span>,<span class="number">0.561318240466811</span>,<span class="number">-0.283936857042294</span>,<span class="number">-0.273776282303907</span>,<span class="number">0.441239433904076</span>,<span class="number">-0.0860629136203344</span>,<span class="number">-0.314675524019288</span>,<span class="number">0.301794479927175</span>,<span class="number">0.0500339580738860</span>,<span class="number">-0.294215306147470</span>,<span class="number">0.170640887043219</span>,<span class="number">0.127676895460899</span>,<span class="number">-0.238443085663152</span>,<span class="number">0.0638314533921737</span>,<span class="number">0.157483497590837</span>,<span class="number">-0.168779371481232</span>,<span class="number">-0.0121711733625802</span>,<span class="number">0.153072982764870</span>,<span class="number">-0.100625734082266</span>,<span class="number">-0.0578353237787552</span>,<span class="number">0.127947779407999</span>,<span class="number">-0.0433755698360067</span>,<span class="number">-0.0778873943022785</span>,<span class="number">0.0935639955835359</span>,<span class="number">-0.00129893145763564</span>,<span class="number">-0.0790210114267234</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">mwArray <span class="title">xx</span><span class="params">(<span class="number">41</span>,<span class="number">1</span>,mxDOUBLE_CLASS)</span></span>;</div><div class="line"><span class="function">mwArray <span class="title">yy</span><span class="params">(<span class="number">41</span>,<span class="number">1</span>,mxDOUBLE_CLASS)</span></span>;</div><div class="line">xx.SetData(x,<span class="number">41</span>);</div><div class="line">yy.SetData(y,<span class="number">41</span>);</div></pre></td></tr></table></figure>
<p>最后调用mplot<br>    mplot(xx,yy);</p>
<p>得到绘图结果：<br><img src="http://i.imgur.com/jg92xMZ.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> OpenSource </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Matlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cpp中回调函数与静态成员]]></title>
      <url>http://markma.tk/posts/QtStudy/Cpp%E4%B8%AD%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>C++回调函数必须为静态函数的原因。以及静态函数调用非静态成员的方法。</p>
</blockquote>
<p>转自<a href="http://blog.csdn.net/u012072012/article/details/45537387" title=" C++回调函数必须为静态函数的原因" target="_blank" rel="external">http://blog.csdn.net/u012072012/article/details/45537387</a><br><a id="more"></a></p>
<h2 id="回调函数简介"><a href="#回调函数简介" class="headerlink" title="回调函数简介"></a>回调函数简介</h2><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p>
<p>为了实现回调，我们必须把this指针给转换掉！可为了在该函数中可以直接操作该类中的成员，我们必须保留this指针！所以这是矛盾的。<br>在类封装回调函数：<br> a.回调函数只能是全局的或是静态的。</p>
<p> b.全局函数会破坏类的封装性，故不予采用。</p>
<p> c.静态函数只能访问类的静态成员，不能访问类中非静态成员</p>
<p>让静态函数访问类的非静态成员的方法：<br>在消息回调的函数参数中传递一个该类的指针即可,就像类中创建一个多线程的回调一样.将类的指针传递给该回调函数,然后用该指针调用类的非静态成员函数和指针.或者用一个类的全局指针数组,保存每一个创建出来的类的this指针,用全局指针去调用。如下：<br> class A()<br>回调函数中访问非静态成员<br>  由于回调函数往往有固定定义，并不接受  A * pThis 参数<br>   如：CALLBACK MyTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime);</p>
<h3 id="【解决方案1】：本方案当遇到有多个类实例对象时会有问题。原因是pThis指针只能指向一个对象。"><a href="#【解决方案1】：本方案当遇到有多个类实例对象时会有问题。原因是pThis指针只能指向一个对象。" class="headerlink" title="【解决方案1】：本方案当遇到有多个类实例对象时会有问题。原因是pThis指针只能指向一个对象。"></a>【解决方案1】：本方案当遇到有多个类实例对象时会有问题。原因是pThis指针只能指向一个对象。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">//静态回调函数</span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;  <span class="comment">//非静态函数 </span></div><div class="line"></div><div class="line">      <span class="keyword">static</span> A * pThis;   <span class="comment">//静态对象指针</span></div><div class="line">&#125;  </div><div class="line"></div><div class="line">A * A::pThis=<span class="literal">NULL</span>;</div><div class="line">A::A()   <span class="comment">//构造函数中将this指针赋给pThis，使得回调函数能通过pThis指针访问本对象</span></div><div class="line">&#123;</div><div class="line">       pThis=<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> A::a()</div><div class="line">&#123;</div><div class="line">      <span class="keyword">if</span> (pThis==<span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">      pThis-&gt;b(); <span class="comment">//回调函数中调用非静态函数 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="【解决方案2】：本方案解决多个类实例对象时方案1的问题。用映射表存所有对象地址，每个对象保存自己的ID号。"><a href="#【解决方案2】：本方案解决多个类实例对象时方案1的问题。用映射表存所有对象地址，每个对象保存自己的ID号。" class="headerlink" title="【解决方案2】：本方案解决多个类实例对象时方案1的问题。用映射表存所有对象地址，每个对象保存自己的ID号。"></a>【解决方案2】：本方案解决多个类实例对象时方案1的问题。用映射表存所有对象地址，每个对象保存自己的ID号。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> CMap&lt;UINT,UINT,A*,A*&gt; CAMap;</div><div class="line"><span class="function"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">//静态回调函数</span></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;  <span class="comment">//非静态函数 </span></div><div class="line">      <span class="keyword">int</span> m_ID;  <span class="comment">//本对象在列表中的ID号</span></div><div class="line">      <span class="keyword">static</span> <span class="keyword">int</span> m_SID;   <span class="comment">//静态当前对象ID        (需要时，将m_ID赋值给m_SID以起到调用本对象函数的功能)</span></div><div class="line">      <span class="keyword">static</span> CAMap m_Map; <span class="comment">//静态对象映射表</span></div><div class="line">&#125;  </div><div class="line"></div><div class="line">CAMap A::m_Map;</div><div class="line"></div><div class="line"><span class="keyword">int</span>   A::m_SID=<span class="number">0</span>;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">A::A()   <span class="comment">//构造函数中将this指针赋给pThis，使得回调函数能通过pThis指针访问本对象</span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">if</span>(m_Map.IsEmpty())</div><div class="line">      &#123;</div><div class="line">   			m_ID=<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123; </div><div class="line">        m_ID=m_Map.GetCount()+<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      m_Map.SetAt( m_ID, <span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> A::a()</div><div class="line">&#123;</div><div class="line">      <span class="keyword">if</span> (m_Map.IsEmpty()) <span class="keyword">return</span>;</div><div class="line">      A * pThis=<span class="literal">NULL</span>;</div><div class="line">      <span class="keyword">if</span>(m_Map.Lookup(m_SID,pThis))</div><div class="line">      &#123;</div><div class="line">   		pThis-&gt;b(); <span class="comment">//回调函数中调用非静态函数 </span></div><div class="line">      &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> QtStudy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt pro文件写法]]></title>
      <url>http://markma.tk/posts/QtStudy/Qt%E4%B8%ADpro%E6%96%87%E4%BB%B6%E5%86%99%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Qt 中pro文件涉及到对项目的一些配置<br><a id="more"></a></p>
</blockquote>
<h1 id="语法简介"><a href="#语法简介" class="headerlink" title="语法简介"></a>语法简介</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>到目前为止，你已经看到在项目文件中使用的=操作符和+=操作符。这里能够提供更多的可供使用的操作符，但是其中的一些需要谨慎地使用，因为它们也许会比你期待的改变的更多。</p>
<h3 id="“-”操作符"><a href="#“-”操作符" class="headerlink" title="“=”操作符"></a>“=”操作符</h3><p>这个操作符简单分配一个值给一个变量。使用方法如下：</p>
<pre><code>TARGET = myapp
</code></pre><p>这将会设置TARGET变量为myapp。这将会删除原来对TARGET的任何设置。</p>
<h3 id="“-”操作符-1"><a href="#“-”操作符-1" class="headerlink" title="“+=”操作符"></a>“+=”操作符</h3><p>这个操作符将会向一个变量的值的列表中添加一个值。使用方法如下：</p>
<pre><code>DEFINES += QT_DLL
</code></pre><p>这将会把QT_DLL添加到被放到makefile中的预处理定义的列表中。</p>
<h3 id="“-”操作符-2"><a href="#“-”操作符-2" class="headerlink" title="“-=”操作符"></a>“-=”操作符</h3><p>这个操作符将会从一个变量的值的列表中移去一个值。使用方法如下：</p>
<pre><code>DEFINES -= QT_DLL
</code></pre><p>这将会从被放到makefile中的预处理定义的列表中移去QT_DLL。</p>
<h3 id="“-”操作符-3"><a href="#“-”操作符-3" class="headerlink" title="“*=”操作符"></a>“*=”操作符</h3><p>这个操作符仅仅在一个值不存在于一个变量的值的列表中的时候，把它添加进去。使用方法如下：</p>
<pre><code>DEFINES *= QT_DLL
</code></pre><p>只用在QT_DLL没有被定义在预处理定义的列表中时，它才会被添加进去。</p>
<h3 id="“-”操作符-4"><a href="#“-”操作符-4" class="headerlink" title="“~=”操作符"></a>“~=”操作符</h3><p>这个操作符将会替换任何与指定的值的正则表达式匹配的任何值。使用方法如下：</p>
<pre><code>DEFINES ~= s/QT_[DT].+/QT
</code></pre><p>这将会用QT来替代任何以QT_D或QT_T开头的变量中的QT_D或QT_T。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域和“if”语句很相似，如果某个条件为真，作用域中的设置就会被处理。作用域使用方法如下：</p>
<pre><code>win32 {
    DEFINES += QT_DLL
}
</code></pre><p>上面的代码的作用是，如果在Windows平台上使用qmake，QT_DLL定义就会被添加到makefile中。如果在Windows平台以外的平台上使用qmake，这个定义就会被忽略。你也可以使用qmake执行一个单行的条件/任务，就像这样：</p>
<pre><code>win32:DEFINES += QT_DLL
</code></pre><p>比如，假设我们想在除了Windows平台意外的所有平台处理些什么。我们想这样使用作用域来达到这种否定效果：</p>
<pre><code>!win32 {
    DEFINES += QT_DLL
}
</code></pre><p>CONFIG行中的任何条目也都是一个作用域。比如，你这样写：</p>
<pre><code>CONFIG += warn_on
</code></pre><p>你将会得到一个称作“warn_on”的作用域。这样将会使在不丢失特定条件下可能所需的所有自定义设置的条件下，很容易地修改项目中的配置。因为你可能把你自己的值放到CONFIG行中，这将会为你的makefile而提供给你一个非常强大的配置工具。比如：</p>
<pre><code>CONFIG += qt warn_on debug
debug {
    TARGET = myappdebug
}
release {
    TARGET = myapp
}
</code></pre><p>在上面的代码中，两个作用域被创建，它们依赖于CONFIG行中设置的是什么。在这个例子中，debug在CONFIG行中，所以TARGET变量被设置为myappdebug。如果release在CONFIG行中，那么TARGET变量将会被设置为myapp。</p>
<p>当然也可以在处理一些设置之前检查两个事物。例如，如果你想检查平台是否是Windows并且线程设置是否被设定，你可以这样写：</p>
<pre><code>win32 {
    thread {
        DEFINES += QT_THREAD_SUPPORT
    }
}
</code></pre><p>为了避免写出许多嵌套作用域，你可以这样使用冒号来嵌套作用域：</p>
<pre><code>win32:thread {
    DEFINES += QT_THREAD_SUPPORT
}
</code></pre><p>一旦一个测试被执行，你也许也要做else/elseif操作。这种情况下，你可以很容易地写出复杂的测试。这需要使用特殊的“else”作用域，它可以和其它作用域进行组合（也可以向上面一样使用冒号），比如：</p>
<pre><code>win32:thread {
    DEFINES += QT_THREAD_SUPPORT
} else:debug {
    DEFINES += QT_NOTHREAD_DEBUG
} else {
    warning(&quot;Unknown configuration&quot;)
}
</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>到目前为止我们遇到的变量都是系统变量，比如DEFINES、SOURCES和HEADERS。你也可以为你自己创建自己的变量，这样你就可以在作用域中使用它们了。创建自己的变量很容易，只要命名它并且分配一些东西给它。比如：</p>
<pre><code>MY_VARIABLE = value
</code></pre><p>现在你对你自己的变量做什么是没有限制的，同样地，qmake将会忽略它们，除非需要在一个作用域中考虑它们。</p>
<p>你也可以通过在其它任何一个变量的变量名前加$$来把这个变量的值分配给当前的变量。例如：</p>
<pre><code>MY_DEFINES = $$DEFINES
</code></pre><p>现在MY_DEFINES变量包含了项目文件在这点时DEFINES变量的值。这也和下面的语句一样：</p>
<pre><code>MY_DEFINES = $${DEFINES}
</code></pre><p>第二种方法允许你把一个变量和其它变量连接起来，而不用使用空格。qmake将允许一个变量包含任何东西（包括<code>$(VALUE)</code>，可以直接在makefile中直接放置，并且允许它适当地扩张，通常是一个环境变量）。无论如何，如果你需要立即设置一个环境变量，然后你就可以使用<code>$$()</code>方法。比如：</p>
<pre><code>MY_DEFINES = $$(ENV_DEFINES)
</code></pre><p>这将会设置MY_DEFINES为环境变量ENV_DEFINES传递给.pro文件地值。另外你可以在替换的变量里调用内置函数。这些函数（不会和下一节中列举的测试函数混淆）列出如下：</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>join( variablename, glue, before, after )</p>
<p>这将会在variablename的各个值中间加入glue。如果这个变量的值为非空，那么就会在值的前面加一个前缀before和一个后缀after。只有variablename是必须的字段，其它默认情况下为空串。如果你需要在glue、before或者after中使用空格的话，你必须提供它们。</p>
<p>member( variablename, position )</p>
<p>这将会放置variablename的列表中的position位置的值。如果variablename不够长，这将会返回一个空串。variablename是唯一必须的字段，如果没有指定位置，则默认为列表中的第一个值。</p>
<p>find( variablename, substr )</p>
<p>这将会放置variablename中所有匹配substr的值。substr也可以是正则表达式，而因此将被匹配。</p>
<pre><code>MY_VAR = one two three four
MY_VAR2 = $$join(MY_VAR, &quot; -L&quot;, -L) -Lfive
MY_VAR3 = $$member(MY_VAR, 2) $$find(MY_VAR, t.*)
</code></pre><p>MY_VAR2将会包含“-Lone -Ltwo -Lthree -Lfour -Lfive”，并且MYVAR3将会包含“three two three”。</p>
<p>system( program_and_args )</p>
<p>这将会返回程序执行在标准输出/标准错误输出的内容，并且正像平时所期待地分析它。比如你可以使用这个来询问有关平台的信息。</p>
<pre><code>UNAME = $$system(uname -s)
contains( UNAME, [lL]inux ):message( This looks like Linux ($$UNAME) to me )
</code></pre><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><p>qmake提供了可以简单执行，但强大测试的内置函数。这些测试也可以用在作用域中（就像上面一样），在一些情况下，忽略它的测试值，它自己使用测试函数是很有用的。</p>
<p>contains( variablename, value )</p>
<p>如果value存在于一个被叫做variablename的变量的值的列表中，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>contains( CONFIG, thread ) {
    DEFINES += QT_THREAD_SUPPORT
}
</code></pre><p>如果thread存在于CONFIG变量的值的列表中时，那么QT_THREAD_SUPPORT将会被加入到DEFINES变量的值的列表中。</p>
<p>count( variablename, number )</p>
<p>如果number与一个被叫做variablename的变量的值的数量一致，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>count( DEFINES, 5 ) {
    CONFIG += debug
}
</code></pre><p>error( string )</p>
<p>这个函数输出所给定的字符串，然后会使qmake退出。例如：</p>
<pre><code>error( &quot;An error has occured&quot; )
</code></pre><p>文本“An error has occured”将会被显示在控制台上并且qmake将会退出。</p>
<p>exists( filename )</p>
<p>如果指定文件存在，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>exists( /local/qt/qmake/main.cpp ) {
    SOURCES += main.cpp
}
</code></pre><p>如果/local/qt/qmake/main.cpp存在，那么main.cpp将会被添加到源文件列表中。</p>
<p>注意可以不用考虑平台使用“/”作为目录的分隔符。</p>
<p>include( filename )</p>
<p>项目文件在这一点时包含这个文件名的内容，所以指定文件中的任何设置都将会被处理。例如：</p>
<pre><code>include( myotherapp.pro )
</code></pre><p>myotherapp.pro项目文件中的任何设置现在都会被处理。</p>
<p>isEmpty( variablename )</p>
<p>这和使用count( variablename, 0 )是一样的。如果叫做variablename的变量没有任何元素，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>isEmpty( CONFIG ) {
    CONFIG += qt warn_on debug
}
</code></pre><p>message( string )</p>
<p>这个函数只是简单地在控制台上输出消息。</p>
<pre><code>message( &quot;This is a message&quot; )
</code></pre><p>文本“This is a message”被输出到控制台上并且对于项目文件的处理将会继续进行。</p>
<p>system( command )</p>
<p>特定指令被执行并且如果它返回一个1的退出值，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>system( ls /bin ) {
    SOURCES += bin/main.cpp
    HEADERS += bin/main.h
}
</code></pre><p>所以如果命令ls /bin返回1，那么bin/main.cpp将被添加到源文件列表中并且bin/main.h将被添加到头文件列表中。</p>
<p>infile( filename, var, val )</p>
<p>如果filename文件（当它被qmake自己解析时）包含一个值为val的变量var，那么这个函数将会返回成功。你也可以不传递第三个参数（val），这时函数将只测试文件中是否分配有这样一个变量var。</p>
<h1 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h1><h2 id="判断编译环境，调用合适的链接库"><a href="#判断编译环境，调用合适的链接库" class="headerlink" title="判断编译环境，调用合适的链接库"></a>判断编译环境，调用合适的链接库</h2><pre><code>win32:contains(QMAKE_HOST.arch, x86_64) {
LIBS += -L$$PWD/x64/ -laticonvert
} else {
LIBS += -L$$PWD/x86/ -laticonvert
}
</code></pre><p>如果在windows平台下，QMAKE_HOST的arch值中包含x86_64（编译环境为64位），则使用64位库，否则使用32位库。</p>
<h2 id="通过include-对多个库进行便捷引用和管理"><a href="#通过include-对多个库进行便捷引用和管理" class="headerlink" title="通过include()对多个库进行便捷引用和管理"></a>通过include()对多个库进行便捷引用和管理</h2><pre><code>include(Libraries/CML/LinkCML.pri)
include(Libraries/BOT/LinkRobot.pri)
include(Libraries/MPC08/LinkMpc08.pri)
include(Libraries/fuzzy/LinkFL.pri)
include(Libraries/FT/LinkFT.pri)
include(Libraries/polaris/LinkNDI.pri)
include(Libraries/MillToolCtrl/LinkMillTool.pri)
</code></pre><p>LinkNDI.pri<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">QT += serialport</div><div class="line"></div><div class="line">INCLUDEPATH += $$PWD</div><div class="line"></div><div class="line">SOURCES += \</div><div class="line">    $$PWD/comm32.cpp \</div><div class="line">    $$PWD/conversion.cpp \</div><div class="line">    $$PWD/baseFunc.cpp \</div><div class="line">    $$PWD/systemCRC.cpp \</div><div class="line">    $$PWD/ndiwidget.cpp</div><div class="line"></div><div class="line">HEADERS +=$$PWD/ndiwidget.h</div><div class="line"></div><div class="line">FORMS+= $$PWD/ndiwidget.ui</div></pre></td></tr></table></figure></p>
<p>…</p>
]]></content>
      
        <categories>
            
            <category> QtStudy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt串口开发QextserialPort]]></title>
      <url>http://markma.tk/posts/OpenSource/Qt%E4%B8%B2%E5%8F%A3%E5%BC%80%E5%8F%91QextserialPort/</url>
      <content type="html"><![CDATA[<p>Qt5以后，官方提供了串口开发的的库Qserialport，但在使用过程中发现仍是有诸多bug存在，比如串口一旦打开就无法关闭，而且整个程序失去响应且无法关闭。再次打开串口会提示串口被占用。</p>
<p>说了这么多，实际使用过程中发现还是QesterialPort使用起来较为稳定。至于使用方法不多赘述，官方给了足够详细的例子。<a href="https://github.com/qextserialport/qextserialport" title="qextserialport" target="_blank" rel="external">https://github.com/qextserialport/qextserialport</a></p>
<p>这里主要介绍一下，使用过程中可能遇到的问题及解决方法。<br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> OpenSource </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenLibrary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt 常见错误汇总]]></title>
      <url>http://markma.tk/posts/QtStudy/Qt%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Qt 中常见错误即解决办法汇总。当然对其他C++ IDE出现的错误也通用。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493350900&amp;di=ee7bbb178d19a43d719319e7ca9b306d&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.f0580.com%2Fadmin%2Fkindeditor%2Fattached%2Fimage%2F20150914%2F20150914090035_68430.jpg" alt=""><br><a id="more"></a></p>
</blockquote>
<h2 id="Link类错误："><a href="#Link类错误：" class="headerlink" title="Link类错误："></a>Link类错误：</h2><h3 id="Link2019"><a href="#Link2019" class="headerlink" title="Link2019:"></a>Link2019:</h3><p>1.删除debug和release文件重新编译。<br>2.若仍出现此错误，说明存在有已声明但还未实现的方法。<br>3.查看是否只包含了头文件，但工程中还没有对应的源文件（.cpp）</p>
<h3 id="Link2001"><a href="#Link2001" class="headerlink" title="Link2001"></a>Link2001</h3><p>一．由于代码错误导致的LNK2001。   </p>
<ol>
<li><p>不相匹配的程序代码或模块定义（.DEF）文件能导致LNK2001。例如,  如果在C＋＋源文件内声明了一变量“var1”，却试图在另一文件内以变量 “VAR1”访问该变量,将发生该错误。   </p>
</li>
<li><p>如果使用的内联函数是在.CPP文件内定义的，而不是在头文件内定义将导致LNK2001错误。 </p>
</li>
<li><p>调用函数时如果所用的参数类型同函数声明时的类型不符将会产生LNK2001。   </p>
</li>
<li><p>试图从基类的构造函数或析构函数中调用虚拟函数时将会导致LNK2001。   </p>
</li>
<li><p>要注意函数和变量的可公用性，只有全局变量、函数是可公用的。静态函数和静态变量具有相同的使用范围限制。当试图从文件外部访问任何没有在该文件内声明的静 态变量时将导致编译错误或LNK2001。函数内声明的变量（局部变量）只能在该函数的范围内使用。C＋＋的全局常量只有静态连接性能。这不同于C，如果试图在C＋＋的多个文件内使用全局变量也会产生LNK2001错误。一种解决的方法是需要时在头文件中加入该常量的初始化代码，并在.CPP文件中包含该头文件；另一种方法是使用时给该变量赋以常数。  </p>
</li>
<li><p>试图调用已声明却尚未定义的静态成员属性（变量）。并且附带Link1120错误，如下图：<br><img src="http://i.imgur.com/ab9KPlU.png" alt=""></p>
</li>
</ol>
<p>二．由于编译和链接的设置而造成的LNK2001<br>  　　1. 如果编译时使用的是/NOD（/NODEFAULTLIB）选项，程序所需要的运行库和MFC库在连接时由编译器写入目标文件模块，但除非在文件中明确包含这些库名，否则这些库不会被链接进工程文件。在这种情况下使用/NOD将导 致错误LNK2001。 </p>
<p>  　　2. 如果没有为wWinMainCRTStartup设定程序入口，在使用Unicode和MFC时将得到“unresolved   external   on   _WinMain@16”的LNK2001错误信息。</p>
<p>  　　3. 使用/MD选项编译时,既然所有的运行库都被保留在动态链接库之内，源文件中对“func”的引用，在目标文件里即对“<strong>imp</strong>func” 的引用。如果试图使用静态LIBC.LIB或LIBCMT.LIB进行连接，将在<strong>imp</strong>func上发生LNK2001；如果不使用/MD选项编译，在使用MSVCxx.LIB连接时也会发生LNK2001。   </p>
<p>  　　4. 使用/ML选项编译时，如用LIBCMT.LIB链接会在_errno上发生LNK2001。 </p>
<p>  　　5. 当编译调试版的应用程序时，如果采用发行版模态库进行连接也会产生LNK2001；同样，使用调试版模态库连接发行版应用程序时也会产生相同的问题。   </p>
<p>  　　6. 不同版本的库和编译器的混合使用也能产生问题，因为新版的库里可能包含早先的版本没有的符号和说明。   </p>
<p>  　　7. 在不同的模块使用内联和非内联的编译选项能够导致LNK2001。如果创建C＋＋库时打开了函数内联（/Ob1或/Ob2），但是在描述该函数的相应头文件里却关闭了函数内联（没有inline关键字），这时将得到该错误信息。为避免该问题的发生，应该在相应的头文件中用inline关键字标志内联函数。   </p>
<p>  　　8. 不正确的/SUBSYSTEM或/ENTRY设置也能导致LNK2001。  </p>
]]></content>
      
        <categories>
            
            <category> QtStudy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt绘图库 QCustomPlot]]></title>
      <url>http://markma.tk/posts/OpenSource/Qt%E7%BB%98%E5%9B%BE%E5%BA%93QCustomplot/</url>
      <content type="html"><![CDATA[<p><a href="http://www.qcustomplot.com/" target="_blank" rel="external">QCustomPlot官网</a><br>Qt借助于QCustomPlot可以更加简单的实现各种所需的绘图功能。本文简单介绍qcustomplot的入门使用，更复杂的功能须参考<a href="http://www.qcustomplot.com/index.php/tutorials/settingup" target="_blank" rel="external">官方教程</a>。<br><a id="more"></a><br><img src="http://i.imgur.com/g4JRcvz.jpg" alt=""></p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a href="http://www.qcustomplot.com/index.php/download" target="_blank" rel="external">http://www.qcustomplot.com/index.php/download</a><br>解压得到头文件qcustomplot.h和源文件qcustomplot.cpp复制粘贴到工程文件夹下添加进工程。<br>在.pro文件中”QT += widgets”后面须加上”printsupport”,否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets printsupport</div></pre></td></tr></table></figure></p>
<p><img src="http://www.qcustomplot.com/images/tutorials/setup-qtcreator-1.png" alt=""><br><img src="http://www.qcustomplot.com/images/tutorials/setup-qtcreator-2.png" alt=""><br>在UI界面中创建一个Widget插件。然后提升为QCustomPlot，头文件对应qcustomplot.h。<br><img src="http://www.qcustomplot.com/images/tutorials/setup-qtcreator-3.png" alt=""><br><img src="http://www.qcustomplot.com/images/tutorials/setup-qtcreator-4.png" alt=""><br>至此安装结束。<br>运行后便可看到带坐标的绘图窗格。</p>
<h2 id="使用实例1"><a href="#使用实例1" class="headerlink" title="使用实例1"></a>使用实例1</h2><p>QCustomPlot中的每一个曲线是一个Graph对象，凡是跟显示数据有关的我们就对Graph进行操作或调用Graph对象提供的方法。<br>一个QCustomPlot里有四个坐标轴，其中xAxis和yAxis就是我们上图看到的x和y坐标轴，还有两个坐标轴xAxis1和yAxis1为上方和右方的x、y坐标，默认隐藏，可以通过程序设计显示。<br>将绘图窗口命名为customPlot，通过容器来存储数据点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// generate some data:</span></div><div class="line">QVector&lt;<span class="keyword">double</span>&gt; x(<span class="number">101</span>), y(<span class="number">101</span>); <span class="comment">// initialize with entries 0..100</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">101</span>; ++i)</div><div class="line">&#123;</div><div class="line">  x[i] = i/<span class="number">50.0</span> - <span class="number">1</span>; <span class="comment">// x goes from -1 to 1</span></div><div class="line">  y[i] = x[i]*x[i]; <span class="comment">// let's plot a quadratic function</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// create graph and assign data to it:</span></div><div class="line">customPlot-&gt;addGraph();</div><div class="line">customPlot-&gt;graph(<span class="number">0</span>)-&gt;setData(x, y);</div><div class="line"><span class="comment">// give the axes some labels:</span></div><div class="line">customPlot-&gt;xAxis-&gt;setLabel(<span class="string">"x"</span>);</div><div class="line">customPlot-&gt;yAxis-&gt;setLabel(<span class="string">"y"</span>);</div><div class="line"><span class="comment">// set axes ranges, so we see all data:</span></div><div class="line">customPlot-&gt;xAxis-&gt;setRange(<span class="number">-1</span>, <span class="number">1</span>);</div><div class="line">customPlot-&gt;yAxis-&gt;setRange(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">customPlot-&gt;replot();</div></pre></td></tr></table></figure></p>
<p><img src="http://www.qcustomplot.com/images/examples/quadraticdemo.png" alt=""></p>
<h2 id="使用实例2-界面交互"><a href="#使用实例2-界面交互" class="headerlink" title="使用实例2-界面交互"></a>使用实例2-界面交互</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ui-&gt;customplot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectAxes |</div><div class="line">                                    QCP::iSelectLegend | QCP::iSelectPlottables);</div><div class="line"></div><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 交互说明</span></div><div class="line"><span class="comment">/**************************************************************/</span></div><div class="line"><span class="comment">/*</span></div><div class="line">QCP::iRangeDrag : 绘图面板拖动</div><div class="line">QCP::iRangeZoom : 绘图面板缩放</div><div class="line">QCP::iSelectAxes : 坐标轴可选性</div><div class="line">QCP::iSelectPlottables : 图线可选性</div><div class="line">QCP::iSelectLegend : 标签可选性</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> OpenSource </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenLibrary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cpp机器人库robot-library]]></title>
      <url>http://markma.tk/posts/OpenSource/cpp%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BA%93robot-library/</url>
      <content type="html"><![CDATA[<p>最近发现了一个比较易用，功能又强大的机器人开源库：<a href="http://www.roboticslibrary.org/" target="_blank" rel="external">Robotics Library (RL)</a>： 一个独立的C++库，包括机器人动力学，运动规划和控制,以及仿真。通过BSD协议授权，可以应用于商业。效果见下图：</p>
<p><div><br><img src="http://i.imgur.com/52mpAAI.gif" alt="puma 560" width="50%"><img src="http://i.imgur.com/Ym2LnKc.gif" alt="humanoid robot" width="50%"><br></div><br><a id="more"></a></p>
<h2 id="cpp机器人库robot-library"><a href="#cpp机器人库robot-library" class="headerlink" title="cpp机器人库robot-library"></a>cpp机器人库robot-library</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>RL官网有已经编译好的几个<a href="http://www.roboticslibrary.org/download" target="_blank" rel="external">demo</a>，本文简单介绍一下几个demo的使用，当然其功能绝对不止demo里面所展示的几项，更强大的功能需要我们借助于官方的源码自己去开发探索了。<br>官方给出了RL在<a href="http://www.roboticslibrary.org/tutorials/install-windows" target="_blank" rel="external">windows的安装方法</a>，虽然很详细，但是按照官方步骤，你需要安装4.85版本的Qt，win32-msvc2010编译器，设置环境变量等等，步骤一步步来确实很繁琐，也难免出错，我安装时就因为错误的安装了mingw版本的Qt而折腾了好几天一度放弃的心都有了。<br>但是其实只要找齐运行库放在bin目录下，直接即可运行，不必安装那么大体积的软件，设置环境变量等等。这里有我整理好的demo，直接解压即可试用。</p>
<h3 id="应用部分"><a href="#应用部分" class="headerlink" title="应用部分"></a>应用部分</h3><p>RL官网有较为详细的<a href="http://www.roboticslibrary.org/tutorials/" target="_blank" rel="external">使用教程</a>，主要有以下几个模块：</p>
<ul>
<li>rlViewDemo：机器人三维模型可视化模块</li>
</ul>
<p>使用方法：<br><code>&quot;%RL_DIR%\bin\rlViewDemo.exe&quot; &quot;%RL_DIR%\share\rl\examples\rlsg\unimation-puma560_boxes.xml&quot;</code></p>
<ul>
<li>rlCollisionDemo：碰撞检测模块</li>
</ul>
<p>使用方法：<br><code>&quot;%RL_DIR%\bin\rlCollisionDemo.exe&quot; &quot;%RL_DIR%\share\rl\examples\rlsg\scene.xml&quot;</code></p>
<ul>
<li>rlPlanDemo：可以避障的轨迹规划模块</li>
</ul>
<p>使用方法：<br><code>&quot;%RL_DIR%\bin\rlPlanDemo.exe&quot; &quot;%RL_DIR%\share\rl\examples\rlplan\unimation-puma560_boxes_rrtConCon.xml&quot;</code></p>
<ul>
<li>rlCoachKin &amp; rlCoachMdl：virtual robot，虚拟机机器人模块，其实就是仿真模块，提供一个虚拟的机器人，通过telnet端口传送关节角度来进行控制。rlCoachKin用stdDH参数表建立机器人模型。rlCoachMdl不同的是不必使用DH即可连接任意的物理链接，并且允许有分支。</li>
</ul>
<p>使用方法：<br>1 打开机器人模型文件<br><code>&quot;%RL_DIR%\bin\rlCoachKin.exe&quot; &quot;%RL_DIR%\share\rl\examples\rlsg\unimation-puma560_boxes.xml&quot; &quot;%RL_DIR%\share\rl\examples\rlkin\unimation-puma560.xml&quot;</code></p>
<p>2 打开telnet端口，（这一步可能要通过控制面板-&gt;程序与功能-&gt;启用或关闭windows功能里面，先把telnet服务端和客户端开启）<br>    telnet localhost 11235</p>
<p>3 输入 2 + 模型ID + 关节角度<br>    2 0 1.57 0.31 0 0 1.57 0</p>
<h3 id="rlCoachKin实例"><a href="#rlCoachKin实例" class="headerlink" title="rlCoachKin实例"></a>rlCoachKin实例</h3><p>demo里有些功能我们可以直接应用，通过telnet端口传输数据即可，省去了写入程序的烦恼。其使用方法，官方给的例子已经很全面了，比葫芦画瓢就可以做出和demo相同的效果。<br>需要注意的有几点：</p>
<ul>
<li>机器人模型可以通过solidworks绘制，并简化为一个杆件为一个零件</li>
<li>另存为wrl 2.0的文件，注意每个杆件单独保存，而且杆件的绘图坐标系要与机器人DH坐标系相吻合。</li>
</ul>
<h2 id="另外再介绍几个机器人相关的软件和库"><a href="#另外再介绍几个机器人相关的软件和库" class="headerlink" title="另外再介绍几个机器人相关的软件和库"></a>另外再介绍几个机器人相关的软件和库</h2><p><a href="http://arvc.umh.es/arte/index_en.html" target="_blank" rel="external">‣ARTE: Robotics Toolbox for Education, a Matlab toolbox focussed on industrial robotic manipulators, with rich 3D graphics, teach pendants and the ABB RAPID language.</a></p>
<p><a href="http://www.coppeliarobotics.com/" target="_blank" rel="external">‣V-REP, a virtual robot experimentation platform, the Swiss army knife of robot simulators.<br>‣OpenRAVE, an environment for testing, developing, and deploying motion planning algorithms in real-world robotics applications.</a></p>
<p><a href="http://openrave.org/docs/latest_stable/" target="_blank" rel="external">‣RoKiSim, a Windows-based simulator with 3D models of common robots which can be driven using a virtual teach pendent.</a></p>
<p><a href="http://www.parallemic.org/RoKiSim.html" target="_blank" rel="external">‣SPACELIB: 3D kinematics and dynamics, C-language and MATLAB. (Legnani, U. di Brescia)</a></p>
<p><a href="https://sourceforge.net/projects/dynamechs/" target="_blank" rel="external">‣Dynamechs a C++ library for simulating the dynamics of multibody systems</a></p>
<p><a href="http://roboop.sourceforge.net/" target="_blank" rel="external">‣ROBOOP, C++ classes for robot kinematics and dynamics (Richard Gourdeau of École Polytechnique de Montreal)</a></p>
<p><a href="http://digilander.libero.it/carmine.lia/jroboop/" target="_blank" rel="external">‣JRoboOp Java wrapper for ROBOOP from the PRISMA Lab at U. Naples.</a></p>
<p><a href="http://ode.org/" target="_blank" rel="external">‣Open Dynamics Engine A free, industrial quality library for simulating articulated rigid body dynamics for example ground vehicles, legged creatures, and moving objects in VR environments.</a></p>
<p><a href="http://www.roboanalyzer.com/about.html" target="_blank" rel="external">‣RoboAnalyzer (IIT Delhi)</a></p>
<p><a href="http://www.orocos.org/" target="_blank" rel="external">‣Orocos (Open Robot Control Software) project(EURON)</a></p>
]]></content>
      
        <categories>
            
            <category> OpenSource </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> OpenLibrary </tag>
            
            <tag> Robot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开源库大全]]></title>
      <url>http://markma.tk/posts/OpenSource/%E5%BC%80%E6%BA%90%E5%BA%93%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>程序员要站在巨人的肩膀上。<br><a id="more"></a></p>
<h2 id="3D图形引擎"><a href="#3D图形引擎" class="headerlink" title="3D图形引擎"></a>3D图形引擎</h2><p>  openGL，事实上的图形学工业标准，提供图形学底层接口，直接使用openGL，对编程有较高要求。</p>
</blockquote>
<p>  openInventor , 对openGL简单地进行了封装，连添加节点地步骤也和openGL相似，不过是由类来操作，更直观一些。目前已经很少人用。</p>
<p>  OSG ， 基于openGL的3d图形引擎，团队有200多人。一个功能覆盖比较全面的openGL封装，但封装还是不彻底，OSG官方文档也不详细，不过在openGL完全可以找到对应的底层函数。在科学计算方面应用广泛，可以使用最新的软硬件技术。</p>
<p>  OGRE ， 基于 openGL或 DirectX3D 的3d图形引擎，团队人数是个位。这个引擎专注于渲染，其他模块可以找其他的开源库来支持，灵活性高。封装比OSG更高层。OGRE的场景管理器非常有特色，这个封装将其与OSG的封装程度隔离开来。另外，与OSG相反，OGRE的性能被大量实际工程所验证，适合快速开发商业软件。</p>
<p>  Irrlicht ， 基于 openGL或 DirectX3D 的3d图形引擎，来自于德国的引擎。 性能优良，不过更新太慢了。</p>
<h2 id="开源CAD"><a href="#开源CAD" class="headerlink" title="开源CAD"></a>开源CAD</h2><p>  openCASCADE，一个开源的CAD引擎，擅长处理3D建模任务。<br>  Draftsight   2D CAD，商业版本，兼容dwg，免费使用，仅需要每年一次邮箱激活<br>  QCAD         2D CAD，这是开源的社区版本，另有收费的商业版本<br>  BRL-CAD      美国陆军使用，三维实体建模系统<br>  FreeCAD      普通用途的2D/3D CAD<br>  sailcut      制作船只的CAD<br>  NaroCAD      参数2D/3D CAD<br>  Archimedes   建筑师使用的CAD<br>  Blender      可以作为CAD使用（使用额外的插件和设置）<br>  PythonCad    2D CAD<br>  Varkon       参数2D/3D CAD<br>  Open CASCADE 几乎所有开源CAD使用的CAD核心，建模能力很强，但其本身显示性能一般。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>  SAX，一个开源的、轻量级的XML工具，最初被java用作XML工具而广泛使用，后来有了其他的接口。</p>
<p>  Xerces，Apache的项目，已经有十年的历史，致力于提供高性能、模块化和扩展性。它尽量少使用类模板、</p>
<pre><code>RTTI及#ifdef等宏定义。 http://xerces.apache.org/
</code></pre><p>  Open XML SDK提供了可用于开发Open XMLDocuments（DOCX, XLSX, PPTX）开源类库，具体支持功能如下：<br>      1、可高性能处理生成文字处理文档、电子表格、幻灯片演示文档；<br>      2、支持文档修改，例如删除文档跟踪内容；<br>      3、支持数据和内容查询、提取，例如将Docx文档转换为Html网页格式、或者从电子表格中提取数据。</p>
<pre><code>https://github.com/OfficeDev/Open-XML-SDK
</code></pre><h2 id="图形语言工具"><a href="#图形语言工具" class="headerlink" title="图形语言工具"></a>图形语言工具</h2><p>  VRML,(Virtual Reality Modeling Language)是一种使用文本保存图形信息的标准，在CAD系统的保存<br>  格式中常见，已经被广泛使用。mp4格式就是基于它的。<a href="http://en.wikipedia.org/wiki/VRML" target="_blank" rel="external">http://en.wikipedia.org/wiki/VRML</a></p>
<h2 id="界面工具"><a href="#界面工具" class="headerlink" title="界面工具"></a>界面工具</h2><p>   Qt 这个不用多说了，非常常用的GUI库，学习快，使用方便。并且跨平台，还有一些非常实用的功能，比如对多线程、数据库、XML、网络等的支持。</p>
<p>   CEGUI 也是一个著名的界面库，相对于Qt，它强调界面的个性化。用户使用CEGUI可以制作出非常漂亮的UI，在游戏中使用比较多。</p>
<h2 id="安装包制作工具"><a href="#安装包制作工具" class="headerlink" title="安装包制作工具"></a>安装包制作工具</h2><p>   WIX   这是一个经典的安装包制作工具，但现在用的人少了。</p>
<p>   NSIS 一个操作简单、小巧高效的安装包制作工具，推荐。</p>
<h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>  Inkscape 一款开源的矢量图制作工具。制作时，直接把jpg、png、bmp等常见格式导入Inkscape，再另存为svg等格式，即完成工作。</p>
<blockquote>
<p>以下内容为网上找到的其他人整理的，很不错，网址： <a href="http://www.cppblog.com/merlinfang/archive/2014/12/26/209311.aspx" target="_blank" rel="external">http://www.cppblog.com/merlinfang/archive/2014/12/26/209311.aspx</a></p>
</blockquote>
<h2 id="值得学习的C语言开源项目"><a href="#值得学习的C语言开源项目" class="headerlink" title="值得学习的C语言开源项目"></a>值得学习的C语言开源项目</h2><ul>
<li><ol>
<li>Webbench<br>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。</li>
</ol>
</li>
</ul>
<p>下载链接：<a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank" rel="external">http://home.tiscali.cz/~cz210552/webbench.html</a></p>
<ul>
<li><ol>
<li>Tinyhttpd<br>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。</li>
</ol>
</li>
</ul>
<p>下载链接：<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="external">http://sourceforge.net/projects/tinyhttpd/</a></p>
<ul>
<li><ol>
<li>cJSON<br>cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。</li>
</ol>
</li>
</ul>
<p>cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。</p>
<p>项目主页:<a href="http://sourceforge.net/projects/cjson/" target="_blank" rel="external">http://sourceforge.net/projects/cjson/</a></p>
<ul>
<li><ol>
<li>CMockery<br>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。</li>
</ol>
</li>
</ul>
<p>主要特点：</p>
<p>免费且开源，google提供技术支持；<br>轻量级的框架，使测试更加快速简单；<br>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;<br>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用<br>下载链接：<a href="http://code.google.com/p/cmockery/downloads/list" target="_blank" rel="external">http://code.google.com/p/cmockery/downloads/list</a></p>
<ul>
<li><ol>
<li>Libev<br>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。</li>
</ol>
</li>
</ul>
<p>下载链接：<a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="external">http://software.schmorp.de/pkg/libev.html</a></p>
<ul>
<li><ol>
<li>Memcached<br>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。</li>
</ol>
</li>
</ul>
<p>下载地址：<a href="http://memcached.org/" target="_blank" rel="external">http://memcached.org/</a></p>
<ul>
<li><ol>
<li>Lua<br>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。</li>
</ol>
</li>
</ul>
<p>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。</p>
<p>下载地址：<a href="http://www.lua.org/" target="_blank" rel="external">http://www.lua.org/</a></p>
<ul>
<li><ol>
<li>SQLite<br>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。</li>
</ol>
</li>
</ul>
<p>下载地址：<a href="http://www.sqlite.org/" target="_blank" rel="external">http://www.sqlite.org/</a> 。</p>
<ul>
<li><ol>
<li>UNIX v6<br>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？</li>
</ol>
</li>
</ul>
<p>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。</p>
<p>下载地址：<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6" target="_blank" rel="external">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6</a></p>
<ul>
<li><ol>
<li>NETBSD<br>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。</li>
</ol>
</li>
</ul>
<p>下载地址：<a href="http://www.netbsd.org/" target="_blank" rel="external">http://www.netbsd.org/</a></p>
<h2 id="C-开源库大全"><a href="#C-开源库大全" class="headerlink" title="C++开源库大全"></a>C++开源库大全</h2><p></p><h3><a name="t0"></a><a name="t0" target="_blank"></a>标准库</h3><p></p>
<ul><br><li><a href="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library%20target=" target="_blank">C++ Standard Library</a>：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li><br><li><a href="http://en.wikipedia.org/wiki/Standard_Template_Library%20target=" target="_blank">Standard Template Library</a>：标准模板库</li><br><li><a href="http://en.wikipedia.org/wiki/C_POSIX_library%20target=" target="_blank">C POSIX library</a>&nbsp;： POSIX系统的C标准库规范</li><br><li><a href="https://github.com/cplusplus%20target=" target="_blank">ISO C++ Standards Committee</a>&nbsp;：C++标准委员会</li><br></ul><br><h3><a name="t1"></a><a name="t1" target="_blank"></a>框架</h3><br><p>C++通用框架和库&nbsp;</p><br><ul><br><li><a href="http://stdcxx.apache.org/%20target=" target="_blank">Apache C++ Standard Library</a>：是一系列算法，容器，迭代器和其他基本组件的集合</li><br><li><a href="http://stlab.adobe.com/%20target=" target="_blank">ASL</a>&nbsp;：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li><br><li><a href="https://github.com/boostorg%20target=" target="_blank">Boost</a>&nbsp;：大量通用C++库的集合。</li><br><li><a href="https://github.com/bloomberg/bde%20target=" target="_blank">BDE</a>&nbsp;：来自于彭博资讯实验室的开发环境。</li><br><li><a href="http://libcinder.org/%20target=" target="_blank">Cinder</a>：提供专业品质创造性编码的开源开发社区。</li><br><li><a href="http://ryan.gulix.cl/fossil.cgi/cxxomfort/%20target=" target="_blank">Cxxomfort</a>：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li><br><li><a href="http://dlib.net/%20target=" target="_blank">Dlib</a>：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li><br><li><a href="https://github.com/paulhodge/EASTL%20target=" target="_blank">EASTL</a>&nbsp;：EA-STL公共部分</li><br><li><a href="https://github.com/sumeetchhetri/ffead-cpp%20target=" target="_blank">ffead-cpp</a>&nbsp;：企业应用程序开发框架</li><br><li><a href="https://github.com/facebook/folly%20target=" target="_blank">Folly</a>：由Facebook开发和使用的开源C++库</li><br><li><a href="https://github.com/julianstorer/JUCE%20target=" target="_blank">JUCE</a>&nbsp;：包罗万象的C++类库，用于开发跨平台软件</li><br><li><a href="https://github.com/facebook/libphenom%20target=" target="_blank">libPhenom</a>：用于构建高性能和高度可扩展性系统的事件框架。</li><br><li><a href="https://github.com/sourcey/libsourcey%20target=" target="_blank">LibSourcey</a>&nbsp;：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li><br><li><a href="https://github.com/koanlogic/libu%20target=" target="_blank">LibU</a>&nbsp;： C语言写的多平台工具库</li><br><li><a href="http://loki-lib.sourceforge.net/%20target=" target="_blank">Loki</a>&nbsp;：C++库的设计，包括常见的设计模式和习语的实现。</li><br><li><a href="https://code.google.com/p/mili/%20target=" target="_blank">MiLi</a>&nbsp;：只含头文件的小型C++库</li><br><li><a href="http://www.openframeworks.cc/%20target=" target="_blank">openFrameworks</a>&nbsp;：开发C++工具包，用于创意性编码。</li><br><li><a href="http://qt-project.org/%20target=" target="_blank">Qt</a>&nbsp;：跨平台的应用程序和用户界面框架</li><br><li><a href="http://code.google.com/p/reason/%20target=" target="_blank">Reason</a>&nbsp;：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li><br><li><a href="http://root.cern.ch/%20target=" target="_blank">ROOT</a>&nbsp;：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li><br><li><a href="http://www.stlport.org/%20target=" target="_blank">STLport</a>：是STL具有代表性的版本</li><br><li><a href="http://stxxl.sourceforge.net/%20target=" target="_blank">STXXL</a>：用于额外的大型数据集的标准模板库。</li><br><li><a href="http://www.ultimatepp.org/%20target=" target="_blank">Ultimate++</a>&nbsp;：C++跨平台快速应用程序开发框架</li><br><li><a href="http://sourceforge.net/projects/wtl/%20target=" target="_blank">Windows Template Library</a>：用于开发Windows应用程序和UI组件的C++库</li><br><li><a href="https://github.com/jll63/yomm11%20target=" target="_blank">Yomm11</a>&nbsp;：C++11的开放multi-methods.</li><br></ul><br><h3><a name="t2"></a><a name="t2" target="_blank"></a>人工智能</h3><br><ul><br><li><a href="https://github.com/aigamedev/btsk%20target=" target="_blank">btsk</a>&nbsp;：游戏行为树启动器工具</li><br><li><a href="http://eodev.sourceforge.net/%20target=" target="_blank">Evolving Objects</a>：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li><br><li><a href="https://github.com/andrometa/neu%20target=" target="_blank">Neu</a>：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li><br></ul><br><h3><a name="t3"></a><a name="t3" target="_blank"></a>异步事件循环</h3><br><ul><br><li><a href="http://think-async.com/%20target=" target="_blank">Boost.Asio</a>：用于网络和底层I/O编程的跨平台的C++库。</li><br><li><a href="http://libev.schmorp.de/%20target=" target="_blank">libev</a>&nbsp;：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li><br><li><a href="http://libevent.org/%20target=" target="_blank">libevent</a>&nbsp;：事件通知库</li><br><li><a href="https://github.com/joyent/libuv%20target=" target="_blank">libuv</a>&nbsp;：跨平台异步I/O。</li><br></ul><br><h3><a name="t4"></a><a name="t4" target="_blank"></a>音频</h3><br><p>音频，声音，音乐，数字化音乐库&nbsp;</p><br><ul><br><li><a href="http://www.fmod.org/%20target=" target="_blank">FMOD</a>&nbsp;：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li><br><li><a href="https://github.com/micknoise/Maximilian%20target=" target="_blank">Maximilian</a>&nbsp;：C++音频和音乐数字信号处理库</li><br><li><a href="http://www.openal.org/%20target=" target="_blank">OpenAL</a>&nbsp;：开源音频库—跨平台的音频API</li><br><li><a href="http://opus-codec.org/%20target=" target="_blank">Opus</a>：一个完全开放的，免版税的，高度通用的音频编解码器</li><br><li><a href="http://www.speex.org/%20target=" target="_blank">Speex</a>：免费编解码器，为Opus所废弃</li><br><li><a href="https://github.com/TonicAudio/Tonic%20target=" target="_blank">Tonic</a>： C++易用和高效的音频合成</li><br><li><a href="http://xiph.org/vorbis/%20target=" target="_blank">Vorbis</a>： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li><br></ul><br><h3><a name="t5"></a><a name="t5" target="_blank"></a>生态学</h3><br><p>生物信息，基因组学和生物技术&nbsp;</p><br><ul><br><li><a href="http://molpopgen.github.io/libsequence/%20target=" target="_blank">libsequence</a>：用于表示和分析群体遗传学数据的C++库。</li><br><li><a href="http://www.seqan.de/%20target=" target="_blank">SeqAn</a>：专注于生物数据序列分析的算法和数据结构。</li><br><li><a href="https://github.com/ekg/vcflib%20target=" target="_blank">Vcflib</a>&nbsp;：用于解析和处理VCF文件的C++库</li><br><li><a href="https://github.com/jewmanchue/wham%20target=" target="_blank">Wham</a>：直接把联想测试应用到BAM文件的基因结构变异。</li><br></ul><br><h3><a name="t6"></a><a name="t6" target="_blank"></a>压缩</h3><br><p>压缩和归档库&nbsp;</p><br><ul><br><li><a href="http://www.bzip.org/%20target=" target="_blank">bzip2</a>：一个完全免费，免费专利和高质量的数据压缩</li><br><li><a href="https://bitbucket.org/attila_afra/doboz/overview%20target=" target="_blank">doboz</a>：能够快速解压缩的压缩库</li><br><li><a href="https://icculus.org/physfs/%20target=" target="_blank">PhysicsFS</a>：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li><br><li><a href="https://projects.kde.org/projects/frameworks/karchive%20target=" target="_blank">KArchive</a>：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li><br><li><a href="https://code.google.com/p/lz4/%20target=" target="_blank">LZ4</a>&nbsp;：非常快速的压缩算法</li><br><li><a href="https://code.google.com/p/lzham/%20target=" target="_blank">LZHAM</a>&nbsp;：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li><br><li><a href="http://www.7-zip.org/sdk.html%20target=" target="_blank">LZMA</a>&nbsp;：7z格式默认和通用的压缩方法。</li><br><li><a href="http://www.matcode.com/lzmat.htm%20target=" target="_blank">LZMAT</a>&nbsp;：及其快速的实时无损数据压缩库</li><br><li><a href="https://code.google.com/p/miniz/%20target=" target="_blank">miniz</a>：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li><br><li><a href="https://github.com/nmoinvaz/minizip%20target=" target="_blank">Minizip</a>：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li><br><li><a href="https://code.google.com/p/snappy/%20target=" target="_blank">Snappy</a>&nbsp;：快速压缩和解压缩</li><br><li><a href="http://zlib.net/%20target=" target="_blank">ZLib</a>&nbsp;：非常紧凑的数据流压缩库</li><br><li><a href="http://zziplib.sourceforge.net/%20target=" target="_blank">ZZIPlib</a>：提供ZIP归档的读权限。</li><br></ul><br><h3><a name="t7"></a><a name="t7" target="_blank"></a>并发性</h3><br><p>并发执行和多线程&nbsp;</p><br><ul><br><li><a href="https://github.com/kylelutz/compute%20target=" target="_blank">Boost.Compute</a>&nbsp;：用于OpenCL的C++GPU计算库</li><br><li><a href="https://github.com/HSA-Libraries/Bolt%20target=" target="_blank">Bolt</a>&nbsp;：针对GPU进行优化的C++模板库</li><br><li><a href="https://github.com/schlangster/cpp.react%20target=" target="_blank">C++React</a>&nbsp;：用于C++11的反应性编程库</li><br><li><a href="https://www.threadingbuildingblocks.org/%20target=" target="_blank">Intel TBB</a>&nbsp;：Intel线程构件块</li><br><li><a href="https://github.com/libclsph/libclsph%20target=" target="_blank">Libclsph</a>：基于OpenCL的GPU加速SPH流体仿真库</li><br><li><a href="https://www.khronos.org/opencl/%20target=" target="_blank">OpenCL</a>&nbsp;：并行编程的异构系统的开放标准</li><br><li><a href="http://openmp.org/%20target=" target="_blank">OpenMP</a>：OpenMP API</li><br><li><a href="http://thrust.github.io/%20target=" target="_blank">Thrust</a>&nbsp;：类似于C++标准模板库的并行算法库</li><br><li><a href="https://github.com/STEllAR-GROUP/hpx/%20target=" target="_blank">HPX</a>&nbsp;：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li><br><li><a href="https://github.com/ddemidov/vexcl%20target=" target="_blank">VexCL</a>&nbsp;：用于OpenCL/CUDA 的C++向量表达式模板库。</li><br></ul><br><h3><a name="t8"></a><a name="t8" target="_blank"></a>容器</h3><br><ul><br><li><a href="https://code.google.com/p/cpp-btree/%20target=" target="_blank">C++ B-tree</a>&nbsp;：基于B树数据结构，实现命令内存容器的模板库</li><br><li><a href="https://github.com/goossaert/hashmap%20target=" target="_blank">Hashmaps</a>： C++中开放寻址哈希表算法的实现</li><br></ul><br><h3><a name="t9"></a><a name="t9" target="_blank"></a>密码学</h3><br><ul><br><li><a href="http://bcrypt.sourceforge.net/%20target=" target="_blank">Bcrypt</a>&nbsp;：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li><br><li><a href="https://github.com/fffaraz/awesome-cpp/blob/master%20target=" target="_blank">BeeCrypt</a>：</li><br><li><a href="http://botan.randombit.net/%20target=" target="_blank">Botan</a>： C++加密库</li><br><li><a href="http://www.cryptopp.com/%20target=" target="_blank">Crypto++</a>：一个有关加密方案的免费的C++库</li><br><li><a href="https://www.gnupg.org/%20target=" target="_blank">GnuPG</a>： OpenPGP标准的完整实现</li><br><li><a href="http://www.gnutls.org/%20target=" target="_blank">GnuTLS</a>&nbsp;：实现了SSL，TLS和DTLS协议的安全通信库</li><br><li><a href="http://www.gnu.org/software/libgcrypt/%20target=" target="_blank">Libgcrypt</a></li><br><li><a href="https://github.com/fffaraz/awesome-cpp/blob/master%20target=" target="_blank">libmcrypt</a></li><br><li><a href="http://www.libressl.org/%20target=" target="_blank">LibreSSL</a>：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li><br><li><a href="https://github.com/libtom/libtomcrypt%20target=" target="_blank">LibTomCrypt</a>：一个非常全面的，模块化的，可移植的加密工具</li><br><li><a href="https://github.com/jedisct1/libsodium%20target=" target="_blank">libsodium</a>：基于NaCI的加密库，固执己见，容易使用</li><br><li><a href="http://www.lysator.liu.se/~nisse/nettle/%20target=" target="_blank">Nettle</a>&nbsp;底层的加密库</li><br><li><a href="http://www.openssl.org/%20target=" target="_blank">OpenSSL</a>&nbsp;： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li><br><li><a href="https://github.com/kokke/tiny-AES128-C%20target=" target="_blank">Tiny AES128 in C</a>&nbsp;：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li><br></ul><br><h3><a name="t10"></a><a name="t10" target="_blank"></a>数据库</h3><br><p>数据库，SQL服务器，ODBC驱动程序和工具&nbsp;</p><br><ul><br><li><a href="https://github.com/paulftw/hiberlite%20target=" target="_blank">hiberlite</a>&nbsp;：用于Sqlite3的C++对象关系映射</li><br><li><a href="https://github.com/redis/hiredis%20target=" target="_blank">Hiredis</a>： 用于Redis数据库的很简单的C客户端库</li><br><li><a href="https://github.com/google/leveldb%20target=" target="_blank">LevelDB</a>： 快速键值存储库</li><br><li><a href="http://symas.com/mdb/%20target=" target="_blank">LMDB</a>：符合数据库四大基本元素的嵌入键值存储</li><br><li><a href="http://www.tangentsoft.net/mysql++/%20target=" target="_blank">MySQL++</a>：封装了MySql的C API的C++ 包装器</li><br><li><a href="https://github.com/facebook/rocksdb%20target=" target="_blank">RocksDB</a>：来自Facebook的嵌入键值的快速存储</li><br><li><a href="http://www.sqlite.org/%20target=" target="_blank">SQLite</a>：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li><br></ul><br><h3><a name="t11"></a><a name="t11" target="_blank"></a>调试</h3><br><p>调试库， 内存和资源泄露检测，单元测试&nbsp;</p><br><ul><br><li><a href="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html%20target=" target="_blank">Boost.Test</a>：Boost测试库</li><br><li><a href="https://github.com/philsquared/Catch%20target=" target="_blank">Catch</a>：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li><br><li><a href="http://www.freedesktop.org/wiki/Software/cppunit/%20target=" target="_blank">CppUnit</a>：由JUnit移植过来的C++测试框架</li><br><li><a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html%20target=" target="_blank">CTest</a>：CMake测试驱动程序</li><br><li><a href="http://code.google.com/p/googletest/%20target=" target="_blank">googletest</a>：谷歌C++测试框架</li><br><li><a href="https://github.com/deplinenoise/ig-debugheap%20target=" target="_blank">ig-debugheap</a>：用于跟踪内存错误的多平台调试堆</li><br><li><a href="https://github.com/zorgnax/libtap%20target=" target="_blank">libtap</a>：用C语言编写测试</li><br><li><a href="http://www.almostinfinite.com/memtrack.html%20target=" target="_blank">MemTrack</a>&nbsp;—用于C++跟踪内存分配</li><br><li><a href="https://bitbucket.org/jonasmeyer/microprofile/overview%20target=" target="_blank">microprofile</a>- 跨平台的网络试图分析器</li><br><li><a href="http://www.jera.com/techinfo/jtns/jtn002.html%20target=" target="_blank">minUnit</a>&nbsp;：使用C写的迷你单元测试框架，只使用了两个宏</li><br><li><a href="https://github.com/Celtoys/Remotery%20target=" target="_blank">Remotery</a>：用于web视图的单一C文件分析器</li><br><li><a href="http://unittest-cpp.sourceforge.net/%20target=" target="_blank">UnitTest++</a>：轻量级的C++单元测试框架</li><br></ul><br><h3><a name="t12"></a><a name="t12" target="_blank"></a>游戏引擎</h3><br><ul><br><li><a href="http://www.cocos2d-x.org/%20target=" target="_blank">Cocos2d-x</a>&nbsp;：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li><br><li><a href="http://gritengine.com/%20target=" target="_blank">Grit</a>&nbsp;：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li><br><li><a href="http://irrlicht.sourceforge.net/%20target=" target="_blank">Irrlicht</a>&nbsp;：C++语言编写的开源高性能的实时#D引擎</li><br><li><a href="http://polycode.org/%20target=" target="_blank">Polycode</a>：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li><br></ul><br><h3><a name="t13"></a><a name="t13" target="_blank"></a>图形用户界面</h3><br><ul><br><li><a href="http://cegui.org.uk/%20target=" target="_blank">CEGUI</a>&nbsp;： 很灵活的跨平台GUI库</li><br><li><a href="http://www.fltk.org/index.php%20target=" target="_blank">FLTK</a>&nbsp;：快速，轻量级的跨平台的C++GUI工具包。</li><br><li><a href="http://www.gtk.org/%20target=" target="_blank">GTK+</a>： 用于创建图形用户界面的跨平台工具包</li><br><li><a href="http://www.gtkmm.org/en/%20target=" target="_blank">gtkmm</a>&nbsp;：用于受欢迎的GUI库GTK+的官方C++接口。</li><br><li><a href="https://github.com/ocornut/imgui%20target=" target="_blank">imgui</a>：拥有最小依赖关系的立即模式图形用户界面</li><br><li><a href="http://librocket.com/%20target=" target="_blank">libRocket</a>&nbsp;：&nbsp;<a href="http://librocket.com/%20target=" target="_blank">libRocket</a>&nbsp;是一个C++ HTML/CSS 游戏接口中间件</li><br><li><a href="http://mygui.info/%20target=" target="_blank">MyGUI</a>&nbsp;：快速，灵活，简单的GUI</li><br><li><a href="http://invisible-island.net/ncurses/%20target=" target="_blank">Ncurses</a>：终端用户界面</li><br><li><a href="http://qcustomplot.com/%20target=" target="_blank">QCustomPlot</a>&nbsp;：没有更多依赖关系的Qt绘图控件</li><br><li><a href="http://qwt.sourceforge.net/%20target=" target="_blank">Qwt</a>&nbsp;：用户与技术应用的Qt 控件</li><br><li><a href="http://qwtplot3d.sourceforge.net/%20target=" target="_blank">QwtPlot3D</a>&nbsp;：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li><br><li><a href="https://github.com/Twolewis/OtterUI%20target=" target="_blank">OtterUI</a>&nbsp;：&nbsp;<a href="https://github.com/Twolewis/OtterUI%20target=" target="_blank">OtterUI</a>&nbsp;是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li><br><li><a href="http://pdcurses.sourceforge.net/%20target=" target="_blank">PDCurses</a>&nbsp;包含源代码和预编译库的公共图形函数库</li><br><li><a href="http://wxwidgets.org/%20target=" target="_blank">wxWidgets</a>&nbsp;C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li><br></ul><br><h3><a name="t14"></a><a name="t14" target="_blank"></a>图形</h3><br><ul><br><li><a href="https://github.com/bkaradzic/bgfx%20target=" target="_blank">bgfx</a>：跨平台的渲染库</li><br><li><a href="http://www.cairographics.org/%20target=" target="_blank">Cairo</a>：支持多种输出设备的2D图形库</li><br><li><a href="https://github.com/horde3d/Horde3D%20target=" target="_blank">Horde3D</a>&nbsp;一个小型的3D渲染和动画引擎</li><br><li><a href="https://github.com/mosra/magnum%20target=" target="_blank">magnum</a>&nbsp;C++11和OpenGL 2D/3D 图形引擎</li><br><li><a href="http://www.ogre3d.org/%20target=" target="_blank">Ogre 3D</a>&nbsp;用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li><br><li><a href="http://www.openscenegraph.org/%20target=" target="_blank">OpenSceneGraph</a>&nbsp;具有高性能的开源3D图形工具包</li><br><li><a href="http://www.panda3d.org/%20target=" target="_blank">Panda3D</a>&nbsp;用于3D渲染和游戏开发的框架，用Python和C++编写。</li><br><li><a href="https://github.com/google/skia%20target=" target="_blank">Skia</a>&nbsp;用于绘制文字，图形和图像的完整的2D图形库</li><br><li><a href="https://github.com/urho3d/Urho3D%20target=" target="_blank">urho3d</a>&nbsp;跨平台的渲染和游戏引擎。</li><br></ul><br><h3><a name="t15"></a><a name="t15" target="_blank"></a>图像处理</h3><br><ul><br><li><a href="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html%20target=" target="_blank">Boost.GIL</a>：通用图像库</li><br><li><a href="http://cimg.sourceforge.net/%20target=" target="_blank">CImg</a>&nbsp;：用于图像处理的小型开源C++工具包</li><br><li><a href="http://www.xdp.it/cximage.htm%20target=" target="_blank">CxImage</a>&nbsp;：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li><br><li><a href="http://freeimage.sourceforge.net/%20target=" target="_blank">FreeImage</a>&nbsp;：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li><br><li><a href="http://gdcm.sourceforge.net/wiki/index.php/Main_Page%20target=" target="_blank">GDCM</a>：Grassroots DICOM 库</li><br><li><a href="http://www.itk.org/%20target=" target="_blank">ITK</a>：跨平台的开源图像分析系统</li><br><li><a href="http://www.imagemagick.org/script/api.php%20target=" target="_blank">Magick++</a>：ImageMagick程序的C++接口</li><br><li><a href="http://www.imagemagick.org/script/api.php%20target=" target="_blank">MagickWnd</a>：ImageMagick程序的C++接口</li><br><li><a href="http://opencv.org/%20target=" target="_blank">OpenCV</a>&nbsp;： 开源计算机视觉类库</li><br><li><a href="https://code.google.com/p/tesseract-ocr/%20target=" target="_blank">tesseract-ocr</a>：OCR引擎</li><br><li><a href="https://github.com/ukoethe/vigra%20target=" target="_blank">VIGRA</a>&nbsp;：用于图像分析通用C++计算机视觉库</li><br><li><a href="http://www.vtk.org/%20target=" target="_blank">VTK</a>&nbsp;：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li><br></ul><br><h3><a name="t16"></a><a name="t16" target="_blank"></a>国际化</h3><br><ul><br><li><a href="http://www.gnu.org/software/gettext/%20target=" target="_blank">gettext</a>&nbsp;：GNU `gettext’</li><br><li><a href="http://site.icu-project.org/%20target=" target="_blank">IBM ICU</a>：提供Unicode 和全球化支持的C、C++ 和Java库</li><br><li><a href="http://www.gnu.org/software/libiconv/%20target=" target="_blank">libiconv</a>&nbsp;：用于不同字符编码之间的编码转换库</li><br></ul><br><h3><a name="t17"></a><a name="t17" target="_blank"></a>Jason</h3><br><ul><br><li><a href="https://github.com/cesanta/frozen%20target=" target="_blank">frozen</a>&nbsp;： C/C++的Jason解析生成器</li><br><li><a href="https://github.com/akheron/jansson%20target=" target="_blank">Jansson</a>&nbsp;：进行编解码和处理Jason数据的C语言库</li><br><li><a href="https://github.com/chrismanning/jbson%20target=" target="_blank">jbson</a>&nbsp;：C++14中构建和迭代BSON data,和Json 文档的库</li><br><li><a href="https://github.com/jeaye/jeayeson%20target=" target="_blank">JeayeSON</a>：非常健全的C++ JSON库，只包含头文件</li><br><li><a href="https://github.com/hjiang/jsonxx%20target=" target="_blank">JSON++</a>&nbsp;： C++ JSON 解析器</li><br><li><a href="https://github.com/udp/json-parser%20target=" target="_blank">json-parser</a>：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li><br><li><a href="https://github.com/dropbox/json11%20target=" target="_blank">json11</a>&nbsp;：一个迷你的C++11 JSON库</li><br><li><a href="https://github.com/amir-s/jute%20target=" target="_blank">jute</a>&nbsp;：非常简单的C++ JSON解析器</li><br><li><a href="https://github.com/vincenthz/libjson%20target=" target="_blank">ibjson</a>：C语言中的JSON解析和打印库，很容易和任何模型集成。</li><br><li><a href="http://sourceforge.net/projects/libjson/%20target=" target="_blank">libjson</a>：轻量级的JSON库</li><br><li><a href="https://github.com/kazuho/picojson%20target=" target="_blank">PicoJSON</a>：C++中JSON解析序列化，只包含头文件</li><br><li><a href="https://github.com/gaudecker/qt-json%20target=" target="_blank">qt-json</a>&nbsp;：用于JSON数据和 QVariant层次间的相互解析的简单类</li><br><li><a href="https://github.com/flavio/qjson%20target=" target="_blank">QJson</a>：将JSON数据映射到QVariant对象的基于Qt的库</li><br><li><a href="https://github.com/miloyip/rapidjson%20target=" target="_blank">RapidJSON</a>： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li><br><li><a href="https://github.com/lloyd/yajl%20target=" target="_blank">YAJL</a>&nbsp;：C语言中快速流JSON解析库</li><br></ul><br><h3><a name="t18"></a><a name="t18" target="_blank"></a>日志</h3><br><ul><br><li><a href="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html%20target=" target="_blank">Boost.Log</a>&nbsp;：设计非常模块化，并且具有扩展性</li><br><li><a href="https://github.com/easylogging/easyloggingpp%20target=" target="_blank">easyloggingpp</a>：C++日志库，只包含单一的头文件。</li><br><li><a href="http://log4cpp.sourceforge.net/%20target=" target="_blank">Log4cpp</a>&nbsp;：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li><br><li><a href="http://www.templog.org/%20target=" target="_blank">templog</a>：轻量级C++库，可以添加日志到你的C++应用程序中</li><br></ul><br><h3><a name="t19"></a><a name="t19" target="_blank"></a>机器学习</h3><br><ul><br><li><a href="https://github.com/BVLC/caffe%20target=" target="_blank">Caffe</a>&nbsp;：快速的神经网络框架</li><br><li><a href="https://github.com/liuliu/ccv%20target=" target="_blank">CCV</a>&nbsp;：以C语言为核心的现代计算机视觉库</li><br><li><a href="http://www.mlpack.org/%20target=" target="_blank">mlpack</a>&nbsp;：可扩展的C++机器学习库</li><br><li><a href="https://github.com/Itseez/opencv%20target=" target="_blank">OpenCV</a>：开源计算机视觉库</li><br><li><a href="https://github.com/GHamrouni/Recommender%20target=" target="_blank">Recommender</a>：使用协同过滤进行产品推荐/建议的C语言库。</li><br><li><a href="https://github.com/shogun-toolbox/shogun%20target=" target="_blank">SHOGUN</a>：Shogun 机器学习工具</li><br><li><a href="https://code.google.com/p/sofia-ml/%20target=" target="_blank">sofia-ml</a>&nbsp;：用于机器学习的快速增量算法套件</li><br></ul><br><h3><a name="t20"></a><a name="t20" target="_blank"></a>数学</h3><br><ul><br><li><a href="http://arma.sourceforge.net/%20target=" target="_blank">Armadillo</a>&nbsp;：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li><br><li><a href="https://code.google.com/p/blaze-lib/%20target=" target="_blank">blaze</a>：高性能的C++数学库，用于密集和稀疏算法。</li><br><li><a href="http://ceres-solver.org/%20target=" target="_blank">ceres-solver</a>&nbsp;：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li><br><li><a href="http://www.cgal.org/%20target=" target="_blank">CGal</a>： 高效，可靠的集合算法集合</li><br><li><a href="http://cmldev.net/%20target=" target="_blank">cml</a>&nbsp;：用于游戏和图形的免费C++数学库</li><br><li><a href="http://eigen.tuxfamily.org/%20target=" target="_blank">Eigen</a>&nbsp;：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li><br><li><a href="http://ggt.sourceforge.net/%20target=" target="_blank">GMTL</a>：数学图形模板库是一组广泛实现基本图形的工具。</li><br><li><a href="https://gmplib.org/%20target=" target="_blank">GMP</a>：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li><br></ul><br><h3><a name="t21"></a><a name="t21" target="_blank"></a>多媒体</h3><br><ul><br><li><a href="http://gstreamer.freedesktop.org/%20target=" target="_blank">GStreamer</a>&nbsp;：构建媒体处理组件图形的库</li><br><li><a href="http://www.live555.com/liveMedia/%20target=" target="_blank">LIVE555 Streaming Media</a>&nbsp;：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li><br><li><a href="https://wiki.videolan.org/LibVLC%20target=" target="_blank">libVLC</a>&nbsp;：libVLC (VLC SDK)媒体框架</li><br><li><a href="https://github.com/wang-bin/QtAV%20target=" target="_blank">QtAv</a>：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li><br><li><a href="http://www.libsdl.org/%20target=" target="_blank">SDL</a>&nbsp;：简单直控媒体层</li><br><li><a href="http://www.sfml-dev.org/%20target=" target="_blank">SFML</a>&nbsp;：快速，简单的多媒体库</li><br></ul><br><h3><a name="t22"></a><a name="t22" target="_blank"></a>网络</h3><br><ul><br><li><a href="http://www.cs.wustl.edu/~schmidt/ACE.html%20target=" target="_blank">ACE</a>：C++面向对象网络变成工具包</li><br><li><a href="http://think-async.com/%20target=" target="_blank">Boost.Asio</a>：用于网络和底层I/O编程的跨平台的C++库</li><br><li><a href="http://casablanca.codeplex.com/%20target=" target="_blank">Casablanca</a>：C++ REST SDK</li><br><li><a href="http://cpp-netlib.org/%20target=" target="_blank">cpp-netlib</a>：高级网络编程的开源库集合</li><br><li><a href="https://github.com/rxi/dyad%20target=" target="_blank">Dyad.c</a>：C语言的异步网络</li><br><li><a href="http://curl.haxx.se/libcurl/%20target=" target="_blank">libcurl</a>&nbsp;:多协议文件传输库</li><br><li><a href="https://github.com/cesanta/mongoose%20target=" target="_blank">Mongoose</a>：非常轻量级的网络服务器</li><br><li><a href="https://github.com/chenshuo/muduo%20target=" target="_blank">Muduo</a>&nbsp;：用于Linux多线程服务器的C++非阻塞网络库</li><br><li><a href="https://github.com/cesanta/net_skeleton%20target=" target="_blank">net_skeleton</a>&nbsp;：C/C++的TCP 客户端/服务器库</li><br><li><a href="https://github.com/riolet/nope.c%20target=" target="_blank">nope.c</a>&nbsp;：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li><br><li><a href="https://github.com/davidmoreno/onion%20target=" target="_blank">Onion</a>&nbsp;:C语言HTTP服务器库，其设计为轻量级，易使用。</li><br><li><a href="https://github.com/pocoproject%20target=" target="_blank">POCO</a>：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li><br><li><a href="https://github.com/OculusVR/RakNet%20target=" target="_blank">RakNet</a>：为游戏开发人员提供的跨平台的开源C++网络引擎。</li><br><li><a href="https://github.com/vinipsmaker/tufao%20target=" target="_blank">Tuf o</a>&nbsp;：用于Qt之上的C++构建的异步Web框架。</li><br><li><a href="https://github.com/zaphoyd/websocketpp%20target=" target="_blank">WebSocket++</a>&nbsp;：基于C++/Boost Aiso的websocket 客户端/服务器库</li><br><li><a href="http://zeromq.org/%20target=" target="_blank">ZeroMQ</a>&nbsp;：高速，模块化的异步通信库</li><br></ul><br><h3><a name="t23"></a><a name="t23" target="_blank"></a>物理学</h3><br><p>动力学仿真引擎&nbsp;</p><br><ul><br><li><a href="https://code.google.com/p/box2d/%20target=" target="_blank">Box2D</a>：2D的游戏物理引擎。</li><br><li><a href="https://github.com/bulletphysics/bullet3%20target=" target="_blank">Bullet</a>&nbsp;：3D的游戏物理引擎。</li><br><li><a href="https://github.com/slembcke/Chipmunk2D%20target=" target="_blank">Chipmunk</a>&nbsp;：快速，轻量级的2D游戏物理库</li><br><li><a href="https://github.com/google/liquidfun%20target=" target="_blank">LiquidFun</a>：2D的游戏物理引擎</li><br><li><a href="http://www.ode.org/%20target=" target="_blank">ODE</a>&nbsp;：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li><br><li><a href="https://github.com/vanderlin/ofxBox2d%20target=" target="_blank">ofxBox2d</a>：Box2D开源框架包装器。</li><br><li><a href="https://github.com/simbody/simbody%20target=" target="_blank">Simbody</a>&nbsp;：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li><br></ul><br><h3><a name="t24"></a><a name="t24" target="_blank"></a>机器人学</h3><br><ul><br><li><a href="http://moos-ivp.org/%20target=" target="_blank">MOOS-IvP</a>&nbsp;：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li><br><li><a href="http://www.mrpt.org/%20target=" target="_blank">MRPT</a>：移动机器人编程工具包</li><br><li><a href="https://github.com/PointCloudLibrary/pcl%20target=" target="_blank">PCL</a>&nbsp;：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li><br><li><a href="http://www.roboticslibrary.org/%20target=" target="_blank">Robotics Library (RL)</a>： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li><br><li><a href="http://www.robwork.dk/jrobwork/%20target=" target="_blank">RobWork</a>：一组C++库的集合，用于机器人系统的仿真和控制。</li><br><li><a href="http://wiki.ros.org/%20target=" target="_blank">ROS</a>&nbsp;：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li><br></ul><br><h3><a name="t25"></a><a name="t25" target="_blank"></a>科学计算</h3><br><ul><br><li><a href="http://www.fftw.org/%20target=" target="_blank">FFTW</a>&nbsp;:用一维或者多维计算DFT的C语言库。</li><br><li><a href="http://www.gnu.org/software/gsl/%20target=" target="_blank">GSL</a>：GNU科学库。</li><br></ul><br><h3><a name="t26"></a><a name="t26" target="_blank"></a>脚本</h3><br><ul><br><li><a href="https://github.com/ChaiScript/ChaiScript/%20target=" target="_blank">ChaiScript</a>&nbsp;：用于C++的易于使用的嵌入式脚本语言。</li><br><li><a href="http://www.lua.org/%20target=" target="_blank">Lua</a>&nbsp;：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li><br><li><a href="https://github.com/dafrito/luacxx%20target=" target="_blank">luacxx</a>：用于创建Lua绑定的C++ 11 API</li><br><li><a href="http://www.swig.org/%20target=" target="_blank">SWIG</a>&nbsp;：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</li><br><li><a href="https://github.com/cesanta/v7%20target=" target="_blank">V7</a>：嵌入式的JavaScript 引擎。</li><br><li><a href="http://code.google.com/p/v8/%20target=" target="_blank">V8</a>&nbsp;：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li><br></ul><br><h3><a name="t27"></a><a name="t27" target="_blank"></a>序列化</h3><br><ul><br><li><a href="http://kentonv.github.io/capnproto/%20target=" target="_blank">Cap’n Proto</a>&nbsp;：快速数据交换格式和RPC系统。</li><br><li><a href="https://github.com/USCiLab/cereal%20target=" target="_blank">cereal</a>&nbsp;：C++11 序列化库</li><br><li><a href="https://github.com/google/flatbuffers%20target=" target="_blank">FlatBuffers</a>&nbsp;：内存高效的序列化库</li><br><li><a href="https://github.com/msgpack/msgpack-c%20target=" target="_blank">MessagePack</a>&nbsp;：C/C++的高效二进制序列化库，例如 JSON</li><br><li><a href="http://code.google.com/p/protobuf/%20target=" target="_blank">protobuf</a>&nbsp;：协议缓冲，谷歌的数据交换格式。</li><br><li><a href="https://github.com/protobuf-c/protobuf-c%20target=" target="_blank">protobuf-c</a>&nbsp;：C语言的协议缓冲实现</li><br><li><a href="https://github.com/real-logic/simple-binary-encoding%20target=" target="_blank">SimpleBinaryEncoding</a>：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li><br><li><a href="https://thrift.apache.org/%20target=" target="_blank">Thrift</a>&nbsp;：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li><br></ul><br><h3><a name="t28"></a><a name="t28" target="_blank"></a>视频</h3><br><ul><br><li><a href="http://www.webmproject.org/code/%20target=" target="_blank">libvpx</a>&nbsp;：VP8/VP9编码解码SDK</li><br><li><a href="https://www.ffmpeg.org/%20target=" target="_blank">FFmpeg</a>&nbsp;：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li><br><li><a href="https://github.com/strukturag/libde265%20target=" target="_blank">libde265</a>&nbsp;：开放的h.265视频编解码器的实现。</li><br><li><a href="https://github.com/cisco/openh264%20target=" target="_blank">OpenH264</a>：开源H.364 编解码器。</li><br><li><a href="http://www.theora.org/%20target=" target="_blank">Theora</a>&nbsp;：免费开源的视频压缩格式。</li><br></ul><br><h3><a name="t29"></a><a name="t29" target="_blank"></a>虚拟机</h3><br><ul><br><li><a href="https://github.com/tekknolagi/carp%20target=" target="_blank">CarpVM</a>：C中有趣的VM，让我们一起来看看这个。</li><br><li><a href="https://github.com/micropython/micropython%20target=" target="_blank">MicroPython</a>&nbsp;：旨在实现单片机上Python3.x的实现</li><br><li><a href="https://github.com/jakogut/tinyvm%20target=" target="_blank">TinyVM</a>：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li><br></ul><br><h3><a name="t30"></a><a name="t30" target="_blank"></a>Web应用框架</h3><br><ul><br><li><a href="https://github.com/bel2125/civetweb%20target=" target="_blank">Civetweb</a>&nbsp;：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li><br><li><a href="http://cppcms.com/%20target=" target="_blank">CppCMS</a>&nbsp;：免费高性能的Web开发框架（不是 CMS）.</li><br><li><a href="https://github.com/ipkn/crow%20target=" target="_blank">Crow</a>&nbsp;：一个C++微型web框架（灵感来自于Python Flask）</li><br><li><a href="https://kore.io/%20target=" target="_blank">Kore</a>&nbsp;:使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li><br><li><a href="http://www.coralbits.com/libonion/%20target=" target="_blank">libOnion</a>：轻量级的库，帮助你使用C编程语言创建web服务器。</li><br><li><a href="https://github.com/jlaine/qdjango/%20target=" target="_blank">QDjango</a>：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li><br><li><a href="http://www.webtoolkit.eu/wt%20target=" target="_blank">Wt</a>&nbsp;：开发Web应用的C++库。</li><br></ul><br><h3><a name="t31"></a><a name="t31" target="_blank"></a>XML</h3><br><p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。——Linus Torvalds&nbsp;</p><br><ul><br><li><a href="http://www.libexpat.org/%20target=" target="_blank">Expat</a>&nbsp;：用C语言编写的xml解析库</li><br><li><a href="http://xmlsoft.org/%20target=" target="_blank">Libxml2</a>&nbsp;：Gnome的xml C解析器和工具包</li><br><li><a href="http://libxmlplusplus.sourceforge.net/%20target=" target="_blank">libxml++</a>&nbsp;：C++的xml解析器</li><br><li><a href="http://pugixml.org/%20target=" target="_blank">PugiXML</a>&nbsp;：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li><br><li><a href="http://rapidxml.sourceforge.net/%20target=" target="_blank">RapidXml</a>&nbsp;：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li><br><li><a href="http://sourceforge.net/projects/tinyxml/%20target=" target="_blank">TinyXML</a>&nbsp;：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li><br><li><a href="https://github.com/leethomason/tinyxml2%20target=" target="_blank">TinyXML2</a>：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li><br><li><a href="https://code.google.com/p/ticpp/%20target=" target="_blank">TinyXML++</a>：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li><br><li><a href="http://xerces.apache.org/xerces-c/%20target=" target="_blank">Xerces-C++</a>&nbsp;：用可移植的C++的子集编写的XML验证解析器。</li><br></ul><br><h3><a name="t32"></a><a name="t32" target="_blank"></a>多项混杂</h3><br><div>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。&nbsp;</div><br><ul><br><li><a href="https://github.com/cppformat/cppformat%20target=" target="_blank">C++ Format</a>&nbsp;：C++的小型，安全和快速格式化库</li><br><li><a href="https://code.google.com/p/casacore/%20target=" target="_blank">casacore</a>&nbsp;：从aips++ 派生的一系列C++核心库</li><br><li><a href="https://github.com/louisdx/cxx-prettyprint%20target=" target="_blank">cxx-prettyprint</a>：用于C++容器的打印库</li><br><li><a href="http://www.dynaforms.com/%20target=" target="_blank">DynaPDF</a>&nbsp;：易于使用的PDF生成库</li><br><li><a href="https://github.com/leafsr/gcc-poison%20target=" target="_blank">gcc-poison</a>&nbsp;：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li><br><li><a href="http://code.google.com/p/googlemock/%20target=" target="_blank">googlemock</a>：编写和使用C++模拟类的库</li><br><li><a href="https://github.com/joyent/http-parser%20target=" target="_blank">HTTP Parser</a>&nbsp;：C的http请求/响应解析器</li><br><li><a href="https://github.com/anrieff/libcpuid%20target=" target="_blank">libcpuid</a>&nbsp;：用于x86 CPU检测盒特征提取的小型C库</li><br><li><a href="https://github.com/avati/libevil%20target=" target="_blank">libevil</a>&nbsp;：许可证管理器</li><br><li><a href="http://www.libusb.org/%20target=" target="_blank">libusb</a>：允许移动访问USB设备的通用USB库</li><br><li><a href="http://pcre.org/%20target=" target="_blank">PCRE</a>：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li><br><li><a href="http://www.deltavsoft.com/%20target=" target="_blank">Remote Call Framework</a>&nbsp;：C++的进程间通信框架。</li><br><li><a href="http://scintilla.org/%20target=" target="_blank">Scintilla</a>&nbsp;：开源的代码编辑控件</li><br><li><a href="https://github.com/wjwwood/serial%20target=" target="_blank">Serial Communication Library</a>&nbsp;：C++语言编写的跨平台，串口库。</li><br><li><a href="https://github.com/antirez/sds%20target=" target="_blank">SDS</a>：C的简单动态字符串库</li><br><li><a href="https://github.com/cesanta/sldr%20target=" target="_blank">SLDR</a>&nbsp;：超轻的DNS解析器</li><br><li><a href="https://github.com/cesanta/slre%20target=" target="_blank">SLRE</a>： 超轻的正则表达式库</li><br><li><a href="https://github.com/rtv/Stage%20target=" target="_blank">Stage</a>&nbsp;：移动机器人模拟器</li><br><li><a href="https://code.google.com/p/vartypes/%20target=" target="_blank">VarTypes</a>：C++/Qt4功能丰富，面向对象的管理变量的框架。</li><br><li><a href="http://zbar.sourceforge.net/%20target=" target="_blank">ZBar</a>：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li><br><li><a href="https://github.com/VerbalExpressions/CppVerbalExpressions%20target=" target="_blank">CppVerbalExpressions</a>&nbsp;：易于使用的C++正则表达式</li><br><li><a href="https://github.com/VerbalExpressions/QtVerbalExpressions%20target=" target="_blank">QtVerbalExpressions</a>：基于C++ VerbalExpressions 库的Qt库</li><br><li><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP%20target=" target="_blank">PHP-CPP</a>：使用C++来构建PHP扩展的库</li><br><li><a href="http://bstring.sourceforge.net/%20target=" target="_blank">Better String</a>&nbsp;：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li><br></ul><br><h3><a name="t33"></a><a name="t33" target="_blank"></a>软件</h3><br><div>用于创建开发环境的软件&nbsp;</div><br><h3><a name="t34"></a><a name="t34" target="_blank"></a>编译器</h3><br><ul><br><li><a href="http://clang.llvm.org/%20target=" target="_blank">Clang</a>&nbsp;:由苹果公司开发的</li><br><li><a href="https://gcc.gnu.org/%20target=" target="_blank">GCC</a>：GNU编译器集合</li><br><li><a href="https://software.intel.com/en-us/c-compilers%20target=" target="_blank">Intel C++ Compiler</a>&nbsp;：由英特尔公司开发</li><br><li><a href="http://llvm.org/%20target=" target="_blank">LLVM</a>&nbsp;：模块化和可重用编译器和工具链技术的集合</li><br><li><a href="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx%20target=" target="_blank">Microsoft Visual C++</a>&nbsp;：MSVC，由微软公司开发</li><br><li><a href="http://www.openwatcom.org/index.php/Main_Page%20target=" target="_blank">Open WatCom</a>&nbsp;：Watcom，C，C++和Fortran交叉编译器和工具</li><br><li><a href="http://bellard.org/tcc/%20target=" target="_blank">TCC</a>&nbsp;：轻量级的C语言编译器</li><br></ul><br><h3><a name="t35"></a><a name="t35" target="_blank"></a>在线编译器</h3><br><ul><br><li><a href="http://codepad.org/%20target=" target="_blank">codepad</a>&nbsp;：在线编译器/解释器，一个简单的协作工具</li><br><li><a href="http://codetwist.com/%20target=" target="_blank">CodeTwist</a>：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li><br><li><a href="http://coliru.stacked-crooked.com/%20target=" target="_blank">coliru</a>&nbsp;：在线编译器/shell， 支持各种C++编译器</li><br><li><a href="http://gcc.godbolt.org/%20target=" target="_blank">Compiler Explorer</a>：交互式编译器，可以进行汇编输出</li><br><li><a href="http://www.compileonline.com/compile_cpp11_online.php%20target=" target="_blank">CompileOnline</a>：Linux上在线编译和执行C++程序</li><br><li><a href="http://ideone.com/%20target=" target="_blank">Ideone</a>&nbsp;：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li><br></ul><br><h3><a name="t36"></a><a name="t36" target="_blank"></a>调试器</h3><br><ul><br><li><a href="http://en.wikipedia.org/wiki/Comparison_of_debuggers%20target=" target="_blank">Comparison of debuggers</a>&nbsp;：来自维基百科的调试器列表</li><br><li><a href="https://www.gnu.org/software/gdb%20target=" target="_blank">GDB</a>&nbsp;：GNU调试器</li><br><li><a href="http://valgrind.org/%20target=" target="_blank">Valgrind</a>：内存调试，内存泄露检测，性能分析工具。</li><br></ul><br><h3><a name="t37"></a><a name="t37" target="_blank"></a>集成开发环境（IDE）</h3><br><ul><br><li><a href="http://www.jetbrains.com/objc/%20target=" target="_blank">AppCode</a>&nbsp;：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li><br><li><a href="http://www.jetbrains.com/clion/%20target=" target="_blank">CLion</a>：来自JetBrains的跨平台的C/C++的集成开发环境</li><br><li><a href="http://www.codeblocks.org/%20target=" target="_blank">Code::Blocks</a>&nbsp;：免费C，C++和Fortran的集成开发环境</li><br><li><a href="http://codelite.org/%20target=" target="_blank">CodeLite</a>&nbsp;：另一个跨平台的免费的C/C++集成开发环境</li><br><li><a href="http://sourceforge.net/projects/orwelldevcpp/%20target=" target="_blank">Dev-C++</a>：可移植的C/C++/C++11集成开发环境</li><br><li><a href="http://www.eclipse.org/cdt/%20target=" target="_blank">Eclipse CDT</a>：基于Eclipse平台的功能齐全的C和C++集成开发环境</li><br><li><a href="http://www.geany.org/%20target=" target="_blank">Geany</a>&nbsp;：轻量级的快速，跨平台的集成开发环境。</li><br><li><a href="http://www-03.ibm.com/software/products/en/visgen%20target=" target="_blank">IBM VisualAge</a>&nbsp;：来自IBM的家庭计算机集成开发环境。</li><br><li><a href="https://github.com/Sarcasm/irony-mode%20target=" target="_blank">Irony-mode</a>：由libclang驱动的用于Emacs的C/C++微模式</li><br><li><a href="https://www.kdevelop.org/%20target=" target="_blank">KDevelop</a>：免费开源集成开发环境</li><br><li><a href="http://www.visualstudio.com/%20target=" target="_blank">Microsoft Visual Studio</a>&nbsp;：来自微软的集成开发环境</li><br><li><a href="https://netbeans.org/%20target=" target="_blank">NetBeans</a>&nbsp;：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li><br><li><a href="http://qt-project.org/%20target=" target="_blank">Qt Creator</a>：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li><br><li><a href="https://github.com/Andersbakken/rtags%20target=" target="_blank">rtags</a>：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li><br><li><a href="https://developer.apple.com/xcode/%20target=" target="_blank">Xcode</a>&nbsp;：由苹果公司开发</li><br><li><a href="https://valloric.github.io/YouCompleteMe/%20target=" target="_blank">YouCompleteMe</a>：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li><br></ul><br><h3><a name="t38"></a><a name="t38" target="_blank"></a>构建系统</h3><br><ul><br><li><a href="https://github.com/rizsotto/Bear%20target=" target="_blank">Bear</a>&nbsp;：用于为clang工具生成编译数据库的工具</li><br><li><a href="https://www.biicode.com/%20target=" target="_blank">Biicode</a>：基于文件的简单依赖管理器。</li><br><li><a href="http://www.cmake.org/%20target=" target="_blank">CMake</a>&nbsp;：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li><br><li><a href="https://github.com/iauns/cpm%20target=" target="_blank">CPM</a>：基于CMake和Git的C++包管理器</li><br><li><a href="http://www.fastbuild.org/docs/home.html%20target=" target="_blank">FASTBuild</a>：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li><br><li><a href="http://martine.github.io/ninja/%20target=" target="_blank">Ninja</a>&nbsp;：专注于速度的小型构建系统</li><br><li><a href="http://www.scons.org/%20target=" target="_blank">Scons</a>&nbsp;：使用Python scipt 配置的软件构建工具</li><br><li><a href="https://github.com/deplinenoise/tundra%20target=" target="_blank">tundra</a>&nbsp;：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li><br><li><a href="http://gittup.org/tup/%20target=" target="_blank">tup</a>：基于文件的构建系统，用于后台监控变化的文件。</li><br></ul><br><h3><a name="t39"></a><a name="t39" target="_blank"></a>静态代码分析</h3><br><ul><br><li><a href="http://cppcheck.sourceforge.net/%20target=" target="_blank">Cppcheck</a>&nbsp;：静态C/C++代码分析工具</li><br><li><a href="https://code.google.com/p/include-what-you-use/%20target=" target="_blank">include-what-you-use</a>&nbsp;：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li><br><li><a href="http://oclint.org/%20target=" target="_blank">OCLint</a>&nbsp;：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li><br><li><a href="http://clang-analyzer.llvm.org/index.html%20target=" target="_blank">Clang Static Analyzer</a>：查找C，C++和Objective-C程序bug的源代码分析工具</li><br><li><a href="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B target=" target="_blank">List of tools for static code analysis</a>&nbsp;：来自维基百科的静态代码分析工具列表</li><br></ul>

<p>转自<a href="http://blog.csdn.net/small_qch/article/details/40544641" target="_blank" rel="external">http://blog.csdn.net/small_qch/article/details/40544641</a></p>
]]></content>
      
        <categories>
            
            <category> OpenSource </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenLibrary </tag>
            
            <tag> Wiki </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python-入门学习（二）]]></title>
      <url>http://markma.tk/posts/Python/Python-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><img src="http://i2.hdslb.com/video/ee/ee2aa44bce1a6d7e4603700a0083b97c.jpg" width="30%"></p>
<blockquote>
<p>上节主要学习了Python语言的特色所在，以及一些基础的变量类型。这节主要学习Python的一些控制流工具。<br><a id="more"></a></p>
</blockquote>
<h1 id="Python-入门学习-二"><a href="#Python-入门学习-二" class="headerlink" title="Python 入门学习(二)"></a>Python 入门学习(二)</h1><h2 id="if语句-if-Statements"><a href="#if语句-if-Statements" class="headerlink" title="if语句 if Statements"></a>if语句 if Statements</h2><p>if语句也许是最知名的控制类型.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = int(input(<span class="string">"Please enter an integer: "</span>))   </div><div class="line">Please enter an integer: <span class="number">42</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>     x = <span class="number">0</span></div><div class="line"><span class="meta">... </span>     print(<span class="string">'Negative changed to zero'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>     print(<span class="string">'Zero'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">1</span>:</div><div class="line"><span class="meta">... </span>     print(<span class="string">'Single'</span>)</div><div class="line"><span class="meta">... </span><span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>     print(<span class="string">'More'</span>)</div><div class="line">...</div><div class="line">More</div></pre></td></tr></table></figure></p>
<h2 id="for语句-for-Statements"><a href="#for语句-for-Statements" class="headerlink" title="for语句 for Statements"></a>for语句 for Statements</h2><p>Python中的for语句和您在C或Pascal语言中的用法略有不同.它既不会遍历数列中的数字(如Pascal中一样),也不会让用户定义迭代步长和中止条件(如C),Python的for循环会以各项在序列中出现的顺序遍历序列(如列表或字符串)的所有项,例如(此处非双关语):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Measure some strings:</span></div><div class="line"><span class="meta">... </span>a = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> a:</div><div class="line"><span class="meta">... </span>    print(x, len(x))</div><div class="line">...</div><div class="line">cat <span class="number">3</span></div><div class="line">window <span class="number">6</span></div><div class="line">defenestrate <span class="number">12</span></div></pre></td></tr></table></figure></p>
<p>在循环中遍历序列时对其修改是不安全的(这只发生在可变序列类型中，如列表).如果您需要在遍历时(例如,复制选定选项)修改列表,您必须遍历一个拷贝.分片表达式会使这变得非常方便:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> a[:]: <span class="comment"># make a slice copy of the entire list</span></div><div class="line"><span class="meta">... </span>   <span class="keyword">if</span> len(x) &gt; <span class="number">6</span>: a.insert(<span class="number">0</span>, x)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</div></pre></td></tr></table></figure></p>
<h2 id="range-函数-The-range-Function"><a href="#range-函数-The-range-Function" class="headerlink" title="range()函数 The range() Function"></a>range()函数 The range() Function</h2><p>如果您需要遍历数字序列，内置函数range正派上用场.它会生成数列,例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line"><span class="meta">... </span>    print(i)</div><div class="line">...</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure></p>
<p>给定的终点并不在产生的序列之内;range(10)会产生10个数值，对这个长度为10的序列中所有项进行索引是合适的.也可以使range以其它数字开始或指定不同的增量(甚至可以是负数;有时这也叫做’步长’):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">####################</span></div><div class="line">range(<span class="number">5</span>, <span class="number">10</span>)</div><div class="line">   <span class="number">5</span> through <span class="number">9</span></div><div class="line"><span class="comment">####################</span></div><div class="line">range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</div><div class="line">   <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span></div><div class="line"><span class="comment">####################</span></div><div class="line">range(<span class="number">-10</span>, <span class="number">-100</span>, <span class="number">-30</span>)</div><div class="line">  <span class="number">-10</span>, <span class="number">-40</span>, <span class="number">-70</span></div></pre></td></tr></table></figure></p>
<p>您可以结合range()和len()函数以遍历一个序列的索引,如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'Mary'</span>, <span class="string">'had'</span>, <span class="string">'a'</span>, <span class="string">'little'</span>, <span class="string">'lamb'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</div><div class="line"><span class="meta">... </span>    print(i, a[i])</div><div class="line">...</div><div class="line"><span class="number">0</span> Mary</div><div class="line"><span class="number">1</span> had</div><div class="line"><span class="number">2</span> a</div><div class="line"><span class="number">3</span> little</div><div class="line"><span class="number">4</span> lamb</div></pre></td></tr></table></figure></p>
<p>然而在大多数情况下,您可以很方便的使用enumerate()函数,详情请查看循环技巧.<br>如果您只是打印range函数,会出现奇怪的现象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(range(<span class="number">10</span>))</div><div class="line">range(<span class="number">0</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>range()会以多种方式返回类似列表的对象,事实上并非真正列表.在您遍历它时,它会返回一个有着连续项的所需的序列对象,但它并不会真正地生成列表，这样做可以节省空间.<br>我们说这个对象可迭代,意思是说适合作为函数和结构体的对象,以期在输入结束时从所获取的连续项中得到某种结果.我们已经看到for语句就是这样的迭代器.list()函数也是一个;它从可迭代量创建新列表:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>))</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure></p>
<p>之后我们将看到更多返回可迭代量及将可迭代量作为参数的函数.</p>
<h2 id="break和continue语句及循环中的else子句-break-and-continue-Statements-and-else-Clauses-on-Loops"><a href="#break和continue语句及循环中的else子句-break-and-continue-Statements-and-else-Clauses-on-Loops" class="headerlink" title="break和continue语句及循环中的else子句 break and continue Statements, and else Clauses on Loops"></a>break和continue语句及循环中的else子句 break and continue Statements, and else Clauses on Loops</h2><p>break语句,像C语言中一样,跳出最小的封闭的for和while循环.continue语句,同样从C语言中借鉴而来,继续循环的下一次迭代.循环语句可以有else子句;它在穷尽列表(以for循环)或条件变为假(以while循环)循环终止时被执行,但循环被break终止时不执行.如下查寻质数的循环例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</div><div class="line"><span class="meta">... </span>            <span class="keyword">break</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></div><div class="line"><span class="meta">... </span>        print(n, <span class="string">'is a prime number'</span>)</div><div class="line">...</div><div class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</div><div class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</div><div class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></div><div class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</div><div class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></div><div class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</div><div class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></div><div class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></div></pre></td></tr></table></figure></p>
<h2 id="pass语句-pass-Statements"><a href="#pass语句-pass-Statements" class="headerlink" title="pass语句 pass Statements"></a>pass语句 pass Statements</h2><p>pass语句什么都不做.它只在语法上需要一条语句但程序不需要任何操作时使用.例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>这通常用作创建最小的类:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>pass可以在您编写新代码时作为函数或条件体的占位符，方便您以更抽象的层次考虑.pass默认将被忽略掉:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">initlog</span><span class="params">(*args)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span>   <span class="comment"># Remember to implement this!</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<h2 id="定义函数-Defining-Functions"><a href="#定义函数-Defining-Functions" class="headerlink" title="定义函数 Defining Functions"></a>定义函数 Defining Functions</h2><p>我们可以创建一个函数来写出一定范围内的斐波纳契数列:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>    <span class="comment"># write Fibonacci series up to n</span></div><div class="line"><span class="meta">... </span>    <span class="string">"""Print a Fibonacci series up to n."""</span></div><div class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</div><div class="line"><span class="meta">... </span>        print(a, end=<span class="string">' '</span>)</div><div class="line"><span class="meta">... </span>        a, b = b, a+b</div><div class="line"><span class="meta">... </span>    print()</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now call the function we just defined:</span></div><div class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></div></pre></td></tr></table></figure></p>
<p>关键字def作为函数定义的开头.之后必须跟着函数名和小括号包括的形参列表.从下一行的开始的表达式构成函数体,其中的所有行都必须缩进.<br>函数体的第一条语句可选为字符串;这个字符串是函数的文档字符亦或doctring.(更多关于docstrings的内容参考文档字符串部分.)Python提供了一些工具可以自动生成在线的或打印的文档,也可以让用户通过代码交互浏览;在您编写的代码中加入文档字符串是个很好的做法,因此请养成编写文档字符串的习惯.<br>函数执行时引入了一个专为函数本地变量提供的符号表.更准确而言,函数中所有变量赋值时都将其值储存在本地符号表中;变量引用时会先查看本地符号表，其次查看封装函数的本地符号表，再次查看全局符号表，最后查看内置函数名字表.这样,全局变量不能在一个函数内部被直接赋值(除非有global语句声明),虽然全局变量可在函数内被引用.<br>一个函数调用实参,该实参会在被调用函数的本地符号表中引用;这样,参数通过被值调用实现传递(值总是一个对象的引用,不是对象的值).[1]当一个函数调用另一个函数时,会为此调用创建一个新的本地符号表.<br>函数定义会在当前符号表中引用函数名.该函数名的值有一个被解释器认作用户定义函数的类型.这个值可以被赋给其它函数名.这即作为一个重命名机制:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>fib</div><div class="line">&lt;function fib at <span class="number">10042</span>ed0&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">100</span>)</div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></div></pre></td></tr></table></figure></p>
<p>如果您有了解过其它语言,您可能不认为fib是个函数,因为它没有返回值,因而更像一个过程.事实上,即使没有返回语句的函数也有一个返回值,尽管是个很无趣的值.这个值即None(其为内置名).如果作为惟一的值输入,解释器通常将不予理会.您可以用print()瞧到它.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(fib(<span class="number">0</span>))</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<p>编写函数返回以斐波那契数列的数字为元素的列表,相对于打印更加简便.(要注意return 的缩进。如果多一个Tab的缩进，将永远返回[0])<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(n)</span>:</span> <span class="comment"># return Fibonacci series up to n</span></div><div class="line"><span class="meta">... </span>    <span class="string">"""Return a list containing the Fibonacci series up to n."""</span></div><div class="line"><span class="meta">... </span>    result = []</div><div class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</div><div class="line"><span class="meta">... </span>        result.append(a)    <span class="comment"># see below</span></div><div class="line"><span class="meta">... </span>        a, b = b, a+b</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> result</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f100 = fib2(<span class="number">100</span>)    <span class="comment"># call it</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f100                <span class="comment"># write the result</span></div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</div></pre></td></tr></table></figure></p>
<p>这个例子一般也用来说明Python的一些新特性:</p>
<ul>
<li>The return statement returns with a value from a function. Return without an expression argument returns None.Falling off the end of a function also returns None.</li>
<li>The statement result.append(a) calls a method of the list object result. A method is a function that‘belongs’<br>to an object and is named obj.methodname, where obj is some object (this may be an expression), and methodname is<br>the name of a method that is defined by the object’s type. Different types define different methods. Methods of<br>different types may have the same name without causing ambiguity. (It is possible to define your own object types<br>and methods, using classes, see Classes) The method append() shown in the example is defined for list objects; it<br>adds a new element at the end of the list. In this example it is equivalent to result = result + [a], but more<br>efficient.</li>
</ul>
<h2 id="深入了解函数定义-More-on-Defining-Functions"><a href="#深入了解函数定义-More-on-Defining-Functions" class="headerlink" title="深入了解函数定义 More on Defining Functions"></a>深入了解函数定义 More on Defining Functions</h2><p>定义函数时也可以添加一些参数.有三种形式,可以组合使用.</p>
<h3 id="默认参数值-Default-Argument-Values"><a href="#默认参数值-Default-Argument-Values" class="headerlink" title="默认参数值 Default Argument Values"></a>默认参数值 Default Argument Values</h3><p>为一个或多个参数指定默认值是最有用的形式.这样会创建一个函数,其参数可少于定义的数量.例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span><span class="params">(prompt, retries=<span class="number">4</span>, complaint=<span class="string">'Yes or no, please!'</span>)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        ok = input(prompt)</div><div class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'y'</span>, <span class="string">'ye'</span>, <span class="string">'yes'</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'n'</span>, <span class="string">'no'</span>, <span class="string">'nop'</span>, <span class="string">'nope'</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        retries = retries - <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">raise</span> IOError(<span class="string">'refusenik user'</span>)</div><div class="line">        print(complaint)</div></pre></td></tr></table></figure></p>
<p>这个函数可以几种方法被调用:</p>
<ul>
<li>giving only the mandatory argument: ask_ok(‘Do you really want to quit?’)</li>
<li>giving one of the optional arguments: ask_ok(‘OK to overwrite the file?’, 2)</li>
<li>or even giving all arguments: ask_ok(‘OK to overwrite the file?’, 2, ‘Come on, only yes or no!’)<br>这个例子中引用了关键字in.它将测试一个序列是否含有某个值. </li>
</ul>
<p>默认值在函数定义的范围内被赋值,所以此处将打印值5.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg=i)</span>:</span></div><div class="line">    print(arg)</div><div class="line"></div><div class="line">i = <span class="number">6</span></div><div class="line">f()</div></pre></td></tr></table></figure></p>
<p>will print 5.<br>重要警告:默认值只被赋予一次.这在默认值为列表,字典或大部分类的实例等可变对象时会产生很大影响.例如,下面的函数将在子序列调用时积累传递给它的参数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=[])</span>:</span></div><div class="line">    L.append(a)</div><div class="line">    <span class="keyword">return</span> L</div><div class="line"></div><div class="line">print(f(<span class="number">1</span>))</div><div class="line">print(f(<span class="number">2</span>))</div><div class="line">print(f(<span class="number">3</span>))</div></pre></td></tr></table></figure></p>
<p>This will print<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure></p>
<p>如果您不想和子序列调用共享默认值,您可以用以下写法替换:<br>def f(a, L=None):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">    L = []</div><div class="line">L.append(a)</div><div class="line"><span class="keyword">return</span> L</div></pre></td></tr></table></figure></p>
<p>如果您不想和子序列调用共享默认值,您可以用以下写法替换:</p>
<h3 id="关键字参数-Keyword-Arguments"><a href="#关键字参数-Keyword-Arguments" class="headerlink" title="关键字参数 Keyword Arguments"></a>关键字参数 Keyword Arguments</h3><p>函数也可以使用keyword = value的关键字参数形式被调用.例如,以下函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>, type=<span class="string">'Norwegian Blue'</span>)</span>:</span></div><div class="line">    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>)</div><div class="line">    print(<span class="string">"-- Lovely plumage, the"</span>, type)</div><div class="line">    print(<span class="string">"-- It's"</span>, state, <span class="string">"!"</span>)</div></pre></td></tr></table></figure></p>
<p>可以以下几种方式被调用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parrot(<span class="number">1000</span>)</div><div class="line">parrot(action = <span class="string">'VOOOOOM'</span>, voltage = <span class="number">1000000</span>)</div><div class="line">parrot(<span class="string">'a thousand'</span>, state = <span class="string">'pushing up the daisies'</span>)</div><div class="line">parrot(<span class="string">'a million'</span>, <span class="string">'bereft of life'</span>, <span class="string">'jump'</span>)</div></pre></td></tr></table></figure></p>
<p>如下调用无效:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parrot()                     <span class="comment"># required argument missing</span></div><div class="line">parrot(voltage=<span class="number">5.0</span>, <span class="string">'dead'</span>)  <span class="comment"># non-keyword argument following keyword</span></div><div class="line">parrot(<span class="number">110</span>, voltage=<span class="number">220</span>)     <span class="comment"># duplicate value for argument</span></div><div class="line">parrot(actor=<span class="string">'John Cleese'</span>)  <span class="comment"># unknown keyword</span></div></pre></td></tr></table></figure></p>
<p>一般来说,一个参数列表必须先是位置参数,之后是关键字参数,其中的关键字必须从形式参数名中选取.形式参数是否有默认值无关紧要.没有参数能多次获取一个值-和位置参数相对应的形式参数在同一调用中不能用作关键字.这里有个因为这种限制导致错误的例子:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def function(a):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; function(0, a=0)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: function() got multiple values for keyword argument 'a'</div></pre></td></tr></table></figure></p>
<p>当<strong>name形式的最终形参出现时,它将接收一个字典(查看映射类型－字典)包含除那些相对应的形式参数外的所有关键字参数.这可以和以<em>name形式的形参结合,该形式形参接收含有超出形参列表的位置参数的元组. (</em>name必须在</strong>name前.)例如,如果我们定义一个函数如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheeseshop</span><span class="params">(kind, *arguments, **keywords)</span>:</span></div><div class="line">    print(<span class="string">"-- Do you have any"</span>, kind, <span class="string">"?"</span>)</div><div class="line">    print(<span class="string">"-- I'm sorry, we're all out of"</span>, kind)</div><div class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</div><div class="line">        print(arg)</div><div class="line">    print(<span class="string">"-"</span> * <span class="number">40</span>)</div><div class="line">    keys = sorted(keywords.keys())</div><div class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keys:</div><div class="line">        print(kw, <span class="string">":"</span>, keywords[kw])</div></pre></td></tr></table></figure></p>
<p>它可能被这样调用: It could be called like this:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cheeseshop(<span class="string">"Limburger"</span>, <span class="string">"It's very runny, sir."</span>,</div><div class="line">           <span class="string">"It's really very, VERY runny, sir."</span>,</div><div class="line">           shopkeeper=<span class="string">"Michael Palin"</span>,</div><div class="line">           client=<span class="string">"John Cleese"</span>,</div><div class="line">           sketch=<span class="string">"Cheese Shop Sketch"</span>)</div></pre></td></tr></table></figure></p>
<p>自然它将打印:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- Do you have any Limburger ?</div><div class="line">-- I'm sorry, we're all out of Limburger</div><div class="line">It's very runny, sir.</div><div class="line">It's really very, VERY runny, sir.</div><div class="line">----------------------------------------</div><div class="line">client : John Cleese</div><div class="line">shopkeeper : Michael Palin</div><div class="line">sketch : Cheese Shop Sketch</div></pre></td></tr></table></figure></p>
<p>注意,关键字参数名列表在打印内容前被创建,通过keys()函数获取所有关键字结果并进行排序;否则参数打印顺序未定义.</p>
<h3 id="可变参数列表-Arbitrary-Argument-Lists"><a href="#可变参数列表-Arbitrary-Argument-Lists" class="headerlink" title="可变参数列表 Arbitrary Argument Lists"></a>可变参数列表 Arbitrary Argument Lists</h3><p>最后,一个最不常用的选择是可以让函数调用可变个数的参数.这些参数被包装进一个元组(查看元组和序列).在这些可变个数的参数之前,可以有零到多个普通的参数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiple_items</span><span class="params">(file, separator, *args)</span>:</span></div><div class="line">    file.write(separator.join(args))</div></pre></td></tr></table></figure></p>
<p>通常,这些可变参数是形参列表中的最后项,因为它将接收所有剩余的传递给函数的参数.任何在*args参数之后的都是‘仅关键字’参数,意味它们只能用作关键字参数.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(*args, sep=<span class="string">"/"</span>)</span>:</span></div><div class="line"><span class="meta">... </span>   <span class="keyword">return</span> sep.join(args)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">"earth"</span>, <span class="string">"mars"</span>, <span class="string">"venus"</span>)</div><div class="line"><span class="string">'earth/mars/venus'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">"earth"</span>, <span class="string">"mars"</span>, <span class="string">"venus"</span>, sep=<span class="string">"."</span>)</div><div class="line"><span class="string">'earth.mars.venus'</span></div></pre></td></tr></table></figure></p>
<h3 id="拆分参数列表-Unpacking-Argument-Lists"><a href="#拆分参数列表-Unpacking-Argument-Lists" class="headerlink" title="拆分参数列表 Unpacking Argument Lists"></a>拆分参数列表 Unpacking Argument Lists</h3><p>另有一种相反的情况: 当你要传递的参数已经是一个列表或元组,但要调用的函数却接受分开一个个的参数值. 这时候你要把已有的列表拆开来. 例如内建函数 range() 要独立的 start, stop 参数. 你可以在调用函数时加一个 *操作符来自动把参数列表拆开:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">3</span>, <span class="number">6</span>))            <span class="comment"># normal call with separate arguments</span></div><div class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(*args))            <span class="comment"># call with arguments unpacked from a list</span></div><div class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p>同样的方法,字典可以通过**操作符传递参数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>)</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</div><div class="line"><span class="meta">... </span>    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>, end=<span class="string">' '</span>)</div><div class="line"><span class="meta">... </span>    print(<span class="string">"E's"</span>, state, <span class="string">"!"</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">"voltage"</span>: <span class="string">"four million"</span>, <span class="string">"state"</span>: <span class="string">"bleedin' demised"</span>, <span class="string">"action"</span>: <span class="string">"VOOM"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>parrot(**d)</div><div class="line">-- This parrot wouldn<span class="string">'t VOOM if you put four million volts through it. E'</span>s bleedin<span class="string">' demised !</span></div></pre></td></tr></table></figure></p>
<h3 id="Lambda形式-Lambda-Forms"><a href="#Lambda形式-Lambda-Forms" class="headerlink" title="Lambda形式 Lambda Forms"></a>Lambda形式 Lambda Forms</h3><p>出于适当的需要,有几种通常在功能性语言和 Lisp 中出现的功能加入到了 Python.通过 lambda 关键字,可以创建很小的匿名函数.这里有一个函数返回它的两个参数的和:”lambda a,b: a+b”. Lambda 形式可以用于任何需要的函数对象.出于语法限制,它们只能有一个单独的表达式.语义上讲,它们只是普通函数定义中的一个语法技巧.类似于嵌套函数定义,lambda 形式可以从包含范围内引用变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>)</div><div class="line"><span class="number">42</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</div><div class="line"><span class="number">43</span></div></pre></td></tr></table></figure></p>
<h3 id="文档字符串-Documentation-Strings"><a href="#文档字符串-Documentation-Strings" class="headerlink" title="文档字符串 Documentation Strings"></a>文档字符串 Documentation Strings</h3><p>这里介绍文档字符串的概念和格式.<br>第一行应该是关于对象用途的简介.简短起见,不用明确的陈述对象名或类型,因为它们可以从别的途径了解到（除非这个名字碰巧就是描述这个函数操作的动词）.这一行应该以大写字母开头,以句号结尾.<br>如果文档字符串有多行,第二行应该空出来,与接下来的详细描述明确分隔.接下来的文档应该有一或多段描述对象的调用约定、边界效应等.<br>Python的解释器不会从多行的文档字符串中去除缩进,所以必要的时候应当自己清除缩进.这符合通常的习惯.第一行之后的第一个非空行决定了整个文档的缩进格式.（我们不用第一行是因为它通常紧靠着起始的引号,缩进格式显示的不清楚.）留白”相当于”是字符串的起始缩进.每一行都不应该有缩进,如果有缩进的话,所有的留白都应该清除掉.留白的长度应当等于扩展制表符的宽度（通常是8个空格）.<br>以下是一个多行文档字符串的示例:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="string">"""Do nothing, but document it.</span></div><div class="line">...</div><div class="line"><span class="meta">... </span>    No, really, it doesn't do anything.</div><div class="line"><span class="meta">... </span>    """</div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_function.__doc__)</div><div class="line">Do nothing, but document it.</div><div class="line"></div><div class="line">    No, really, it doesn<span class="string">'t do anything.</span></div></pre></td></tr></table></figure></p>
<h2 id="插曲-编码类型-Intermezzo-Coding-Style"><a href="#插曲-编码类型-Intermezzo-Coding-Style" class="headerlink" title="插曲:编码类型 Intermezzo: Coding Style"></a>插曲:编码类型 Intermezzo: Coding Style</h2><p>既然您已经打算编写更长更复杂的Python程序块,是时候讨论下编码类型.许多语言都可以以不同的类型编写(简洁,格式化),其中一些更具可读性.让他人方便阅读您的代码是个不错的主意,采用一套漂亮的编码类型帮助巨大.<br>对于Python,PEP8已经成为大多数项目都支持的风格指南;它推行良好的可读性和养眼的编码类型.每一位Python开发人员都应有所了解;以下是从中摘出的一些重要的关键点:<br>使用4个空格缩进，不要使用tabs</p>
<ul>
<li>4个空格是不大(易读)不小(允许深层嵌套)的折中缩进量.制表符会导致些困惑,也容易被忽略. 4 spaces are a good compromise between small indentation (allows greater nesting depth) and large indentation (easier to read). Tabs introduce confusion, and are best left out.</li>
<li>换行,以保证每行不超过79字符.<br>这可以帮助小屏幕用户，也可以在大屏幕上并排显示几个代码文件. This helps users with small displays and makes it possible to have several code files side-by-side on larger displays.</li>
<li>使用空行来分隔函数和类,以及函数内部的大块代码.</li>
<li>如果可能,在一行中添加相应的注释</li>
<li>使用文档字符串</li>
<li>操作符旁及逗号后使用空格,不要在在包围结构中直接使用: a = f(1, 2) + g(3, 4).</li>
<li>类与函数命名一致;惯例对类使用驼峰式写法,对于函数和方法采用小写和下划线结合写法.一直使用self作为第一个方法参数的名字(详情请查看初探类)</li>
<li>如果您打算在国际环境中使用,请不要使用奇怪的编码.Python默认编码UTF-8及纯ASCII为最佳选择.</li>
<li>同样的,如果在读取及维护代码时很少用到其它语言，请不要在标识符中使用非ASCII字符<h2 id="附件Footnotes"><a href="#附件Footnotes" class="headerlink" title="附件Footnotes"></a>附件Footnotes</h2>实际上，调用对像参考……<br>[1]Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it (items inserted into a list).</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python-入门学习（一）]]></title>
      <url>http://markma.tk/posts/Python/Python-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><img src="http://i2.hdslb.com/video/ee/ee2aa44bce1a6d7e4603700a0083b97c.jpg" width="30%"></p>
<blockquote>
<p>作为脚本语言之王的Python的魅力究竟何在。今天，我们就跨入Python学习的历程。去探索Python的魅力。</p>
<blockquote>
<p>Python（英国发音：/ˈpaɪθən/ 美国发音：/ˈpaɪθɑːn/）, 是一种面向对象、解释型计算机程序设计语言，由Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。<br>Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议[1]  。<br>Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。<br>Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中[2]  有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供跨平台的实现。<br><a id="more"></a></p>
</blockquote>
</blockquote>
<h2 id="Python-入门学习-一"><a href="#Python-入门学习-一" class="headerlink" title="Python 入门学习(一)"></a>Python 入门学习(一)</h2><h3 id="Python语言的特色"><a href="#Python语言的特色" class="headerlink" title="Python语言的特色"></a>Python语言的特色</h3><ul>
<li><p>简单<br>Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p>
</li>
<li><p>易学<br>就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。</p>
</li>
<li><p>免费、开源<br>Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。</p>
</li>
<li><p>高层语言<br>当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。</p>
</li>
<li><p>可移植性<br>由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。</p>
</li>
</ul>
<blockquote>
<p>这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC！</p>
</blockquote>
<ul>
<li>解释性<br>这一点需要一些解释。</li>
</ul>
<p>一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。</p>
<p>而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码 运行 程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。</p>
<ul>
<li><p>面向对象<br>Python即支持面向过程的编程也支持面向对象的编程。在 面向过程 的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在 面向对象 的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。</p>
</li>
<li><p>可扩展性<br>如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</p>
</li>
<li><p>可嵌入性<br>你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。</p>
</li>
<li><p>丰富的库<br>Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。</p>
</li>
<li><p>除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。</p>
</li>
</ul>
<h3 id="初识Python"><a href="#初识Python" class="headerlink" title="初识Python"></a>初识Python</h3><h4 id="Hello-Python"><a href="#Hello-Python" class="headerlink" title="Hello Python !"></a>Hello Python !</h4><p>深入浅出，我们依然从最简单的<em>Hell-world</em>入门。<br><figure class="highlight python"><figcaption><span>Hello Python</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"Hello Python"</span>)</div></pre></td></tr></table></figure><br>输出:<code>Hello Python</code></p>
<h4 id="Python-语法的不同之处-Tab-键的使用"><a href="#Python-语法的不同之处-Tab-键的使用" class="headerlink" title="Python 语法的不同之处-Tab 键的使用"></a>Python 语法的不同之处-Tab 键的使用</h4><p>有些编程基础的朋友们都知道，在C/C++中程序代码往往会被大括号”{}”所包裹，被称为程序段，那么程序段中的变量，不做特殊说明的话一般为局部变量，其生命周期到括号结束为至。而在Python中，程序段落不再使用{},取而代之的是Tab键的缩进，使得代码更加简洁美观。同时<br>Python中不必使用”;”来代表一句程序的结尾了。</p>
<p>假设 <code>i=2</code><br><figure class="highlight python"><figcaption><span>1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)</div><div class="line">print(<span class="string">"1"</span>)</div></pre></td></tr></table></figure><br>输出: <code>1</code> </p>
<figure class="highlight python"><figcaption><span>2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)</div><div class="line">	print(<span class="string">"2"</span>)</div></pre></td></tr></table></figure>
<p>输出: <code>2</code><br>可以看到同一缩进列的代码关系平行如兄弟顺序执行，而缩进越靠后的代码辈分越低，也就是程序段越深。</p>
<h4 id="源代码编码"><a href="#源代码编码" class="headerlink" title="源代码编码"></a>源代码编码</h4><p>默认的，Python源文件是以UTF-8编码。在这个编码下，在世界上的大部分语言可以共用字符串，标识符和注释——虽然标准库只使用ASCII字符识别码，这项任何可移植代码都应遵循的公约。为了正确地显示所有的字符，你的编辑器必须能辨认UTF-8编码，而且必须在文件中使用支持所有字符的字体。<br>也可以为源文件指定不同的编码。为了做到这一点，在 #! 行之后添加一个用于限定源文件编码的相当特殊的注释行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: encoding -*-</span></div></pre></td></tr></table></figure><br>通过此声明，在上例中，源文件的所有东西都将被转换为encoding编码而不是UTF-8编码。</p>
<h3 id="Python概述"><a href="#Python概述" class="headerlink" title="Python概述"></a>Python概述</h3><h4 id="把Python作为一个计算器"><a href="#把Python作为一个计算器" class="headerlink" title="把Python作为一个计算器"></a>把Python作为一个计算器</h4><p>让我们尝试一些简单的Python命令。打开解释器等待主提示符 &gt;&gt;&gt; 的出现（不会花很久）。</p>
<h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h5><p>解释器可以作为一个简单的计算器：您可以在解释器里输入一个表达式，它将输出表达式的值。表达式的语法很直白： +, -, * 和 / 和在许多其它语言（如Pascal或C）里一样；括号可以用来为运算分组。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>+<span class="number">2</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 这是一行注释</span></div><div class="line"><span class="meta">... </span><span class="number">2</span>+<span class="number">2</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>+<span class="number">2</span>  <span class="comment"># 这是和代码同在一行的注释</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">50</span><span class="number">-5</span>*<span class="number">6</span>)/<span class="number">4</span></div><div class="line"><span class="number">5.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span>/<span class="number">5</span> <span class="comment"># 整数除法不会丢失分数部分</span></div><div class="line"><span class="number">1.6</span></div></pre></td></tr></table></figure><br>注意：在不同的机器上浮点运算的结果可能会不一样。之后我们会介绍有关控制浮点运算输出结果的内容。关于浮点数及其表示方式的微妙之处的全面细致的讨论，请参考《浮点运算：问题和限制》。<br>在整数除法中，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // ：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 整数除法返回向下取整后的结果：</span></div><div class="line"><span class="meta">... </span><span class="number">7</span>//<span class="number">3</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span>//<span class="number">-3</span></div><div class="line"><span class="number">-3</span></div></pre></td></tr></table></figure><br>等号（‘=’）用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>width = <span class="number">20</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>height = <span class="number">5</span>*<span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>width * height</div><div class="line"><span class="number">900</span></div></pre></td></tr></table></figure><br>一个值可以同时赋予多个变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = y = z = <span class="number">0</span>  <span class="comment"># 清零 x, y 和 z</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>z</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure><br>变量在使用前必须先“定义”（即赋予变量一个值），否则会出现错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 尝试访问一个未定义的变量</span></div><div class="line"><span class="meta">... </span>n</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">NameError: name <span class="string">'n'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</div></pre></td></tr></table></figure><br>浮点数得到完全的支持；不同类型的数混合运算时会将整数转换为浮点数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">3.75</span> / <span class="number">1.5</span></div><div class="line"><span class="number">7.5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7.0</span> / <span class="number">2</span></div><div class="line"><span class="number">3.5</span></div></pre></td></tr></table></figure><br>复数也支持；虚数带有 j 或 J 后缀。带有非零实部的复数记为 (实部+虚部j)，或者使用 complex(实部, 虚部) 函数来创建。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1j</span> * <span class="number">1J</span></div><div class="line">(<span class="number">-1</span>+<span class="number">0j</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1j</span> * complex(<span class="number">0</span>, <span class="number">1</span>)</div><div class="line">(<span class="number">-1</span>+<span class="number">0j</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>+<span class="number">1j</span>*<span class="number">3</span></div><div class="line">(<span class="number">3</span>+<span class="number">3j</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">3</span>+<span class="number">1j</span>)*<span class="number">3</span></div><div class="line">(<span class="number">9</span>+<span class="number">3j</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>+<span class="number">2j</span>)/(<span class="number">1</span>+<span class="number">1j</span>)</div><div class="line">(<span class="number">1.5</span>+<span class="number">0.5j</span>)</div></pre></td></tr></table></figure><br>复数总是由两个浮点数来表示，实部和虚部。若要从复数z中提取其中一部分，可使用 z.real 和 z.imag。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1.5</span>+<span class="number">0.5j</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.real</div><div class="line"><span class="number">1.5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.imag</div><div class="line"><span class="number">0.5</span></div></pre></td></tr></table></figure><br>浮点数和整数之间的转换函数（float(), int()）不能用于复数——尚没办法将复数转换为实数。但可以使用 abs(z) 获得复数的模（结果是浮点数），或者使用 z.real 获取其实部：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=3.0+4.0j</div><div class="line">&gt;&gt;&gt; float(a)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: can't convert complex to float; use abs(z)</div><div class="line">&gt;&gt;&gt; a.real</div><div class="line">3.0</div><div class="line">&gt;&gt;&gt; a.imag</div><div class="line">4.0</div><div class="line">&gt;&gt;&gt; abs(a)  # sqrt(a.real**2 + a.imag**2)</div><div class="line">5.0</div></pre></td></tr></table></figure><br>在交互模式中，最后被输出的表达式结果被赋值给变量 <em> 。这能使您在把Python作为一个桌面计算器使用时使后续计算更方便，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tax = <span class="number">12.5</span> / <span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>price = <span class="number">100.50</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>price * tax</div><div class="line"><span class="number">12.5625</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>price + _</div><div class="line"><span class="number">113.0625</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(_, <span class="number">2</span>)</div><div class="line"><span class="number">113.06</span></div></pre></td></tr></table></figure><br>此处， </em> 变量就是最后一个计算式的运算结果,应被用户视为只读变量。不要显式地给它赋值——这样您将会创建一个具有相同名称的独立的本地变量，并且屏蔽了这个内置变量的功能。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>除了数字，Python也能操作字符串。字符串有几种表达方式，可以使用单引号或双引号括起来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'spam eggs'</span></div><div class="line"><span class="string">'spam eggs'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'doesn\'t'</span></div><div class="line"><span class="string">"doesn't"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"doesn't"</span></div><div class="line"><span class="string">"doesn't"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"Yes," he said.'</span></div><div class="line"><span class="string">'"Yes," he said.'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"\"Yes,\" he said."</span></div><div class="line"><span class="string">'"Yes," he said.'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"Isn\'t," she said.'</span></div><div class="line"><span class="string">'"Isn\'t," she said.'</span></div></pre></td></tr></table></figure><br>解释器以输入时相同的方式输出字符串操作的结果，即使用引号括起来，并且使用反斜杠转义引号和其它特殊字符来准确地表示。如果字符串包含有单引号但不含双引号，则字符串会用双引号括起来，否则用单引号括起来。对于这样的输入字符串，print() 函数会产生更易读的输出。<br>跨行的字面字符串可用以下几种方法表示。使用续行符，即在每行最后一个字符后使用反斜线来说明下一行是上一行逻辑上的延续：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hello = <span class="string">"This is a rather long string containing\n\</span></div><div class="line">several lines of text just as you would do in C.\n\</div><div class="line">    Note that whitespace at the beginning of the line is\</div><div class="line"> significant."</div><div class="line"></div><div class="line">print(hello)</div></pre></td></tr></table></figure><br>注意，其中的换行符仍然要使用 \n 表示——反斜杠后的换行符被丢弃了。以上例子将如下输出：<br>    This is a rather long string containing<br>    several lines of text just as you would do in C.<br>        Note that whitespace at the beginning of the line is significant.<br>或者，字符串可以被 “”” （三个双引号）或者 ‘’’ （三个单引号）括起来。使用三引号时，换行符不需要转义，它们会包含在字符串中。以下的例子使用了一个转义符，避免在最开始产生一个不需要的空行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"""\</span></div><div class="line">Usage: thingy [OPTIONS]</div><div class="line">     -h                        Display this usage message</div><div class="line">     -H hostname               Hostname to connect to</div><div class="line">""")</div></pre></td></tr></table></figure><br>其输出如下：<br>    Usage: thingy [OPTIONS]<br>         -h                        Display this usage message<br>         -H hostname               Hostname to connect to<br>如果我们使用“原始 (raw)”字符串，那么 \n 不会被转换成换行，行末的的反斜杠，以及源码中的换行符，都将作为数据包含在字符串内。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hello = <span class="string">r"This is a rather long string containing\n\</span></div><div class="line">several lines of text much as you would do in C."</div><div class="line"></div><div class="line">print(hello)</div></pre></td></tr></table></figure><br>将会输出：<br>    This is a rather long string containing\n\<br>    several lines of text much as you would do in C.<br>字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Help'</span> + <span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word</div><div class="line"><span class="string">'HelpA'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&lt;'</span> + word*<span class="number">5</span> + <span class="string">'&gt;'</span></div><div class="line"><span class="string">'&lt;HelpAHelpAHelpAHelpAHelpA&gt;'</span></div></pre></td></tr></table></figure><br>两个紧邻的字面字符串将自动被串连；上例的第一行也可以写成 word = ‘Help’ ‘A’ ；这样的操作只在两个字面值间有效，不能随意用于字符串表达式中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; 'str' 'ing'                   #  &lt;-  这样操作正确</div><div class="line">'string'</div><div class="line">&gt;&gt;&gt; 'str'.strip() + 'ing'   #  &lt;-  这样操作正确</div><div class="line">'string'</div><div class="line">&gt;&gt;&gt; 'str'.strip() 'ing'     #  &lt;-  这样操作错误</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">    'str'.strip() 'ing'</div><div class="line">                      ^</div><div class="line">SyntaxError: invalid syntax</div></pre></td></tr></table></figure><br>字符串可以被索引；就像 C 语言一样，字符串的第一个字符的索引为 0。没有单独的字符类型；一个字符就是长度为一的字符串。就像Icon编程语言一样，子字符串可以使用分切符来指定：用冒号分隔的两个索引。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>]</div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]</div><div class="line"><span class="string">'Hl'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">4</span>]</div><div class="line"><span class="string">'ep'</span></div></pre></td></tr></table></figure><br>默认的分切索引很有用：默认的第一个索引为零，第二个索引默认为字符串可以被分切的长度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>]    <span class="comment"># 前两个字符</span></div><div class="line"><span class="string">'He'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:]    <span class="comment"># 除了前两个字符之外，其后的所有字符</span></div><div class="line"><span class="string">'lpA'</span></div></pre></td></tr></table></figure><br>不同于C字符串的是，Python字符串不能被改变。向一个索引位置赋值会导致错误：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; word[0] = 'x'</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: 'str' object does not support item assignment</div><div class="line">&gt;&gt;&gt; word[:1] = 'Splat'</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: 'str' object does not support slice assignment</div></pre></td></tr></table></figure><br>然而，用组合内容的方法来创建新的字符串是简单高效的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'x'</span> + word[<span class="number">1</span>:]</div><div class="line"><span class="string">'xelpA'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Splat'</span> + word[<span class="number">4</span>]</div><div class="line"><span class="string">'SplatA'</span></div></pre></td></tr></table></figure><br>在分切操作字符串时，有一个很有用的规律： s[:i] + s[i:] 等于 s.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + word[<span class="number">2</span>:]</div><div class="line"><span class="string">'HelpA'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">3</span>] + word[<span class="number">3</span>:]</div><div class="line"><span class="string">'HelpA'</span></div></pre></td></tr></table></figure><br>对于有偏差的分切索引的处理方式也很优雅：一个过大的索引将被字符串的大小取代，上限值小于下限值将返回一个空字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">1</span>:<span class="number">100</span>]</div><div class="line"><span class="string">'elpA'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">10</span>:]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">1</span>]</div></pre></td></tr></table></figure><br>在索引中可以使用负数，这将会从右往左计数。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-1</span>]     <span class="comment"># 最后一个字符</span></div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>]     <span class="comment"># 倒数第二个字符</span></div><div class="line"><span class="string">'p'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>:]    <span class="comment"># 最后两个字符</span></div><div class="line"><span class="string">'pA'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">-2</span>]    <span class="comment"># 除了最后两个字符之外，其前面的所有字符</span></div><div class="line"><span class="string">'Hel'</span></div></pre></td></tr></table></figure><br>但要注意， -0 和 0 完全一样，所以 -0 不会从右开始计数！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-0</span>]     <span class="comment"># (既然 -0 等于 0)</span></div><div class="line"><span class="string">'H'</span></div></pre></td></tr></table></figure><br>超出范围的负数索引会被截去多余部分，但不要尝试在一个单元素索引（非分切索引）里使用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; word[-100:]</div><div class="line">'HelpA'</div><div class="line">&gt;&gt;&gt; word[-10]    # 错误</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">IndexError: string index out of range</div></pre></td></tr></table></figure><br>有一个方法可以让您记住分切索引的工作方式，想像索引是指向字符之间，第一个字符左边的数字是 0。接着，有n个字符的字符串最后一个字符的右边是索引n，例如：<br>      +—+—+—+—+—+<br>      | H | e | l | p | A |<br>      +—+—+—+—+—+<br>      0   1   2   3   4   5<br>     -5  -4  -3  -2  -1<br>第一行的数字 0…5 给出了字符串中索引的位置；第二行给出了相应的负数索引。分切部分从 i 到 j 分别由在边缘被标记为 i 和 j 的全部字符组成。<br>对于非负数分切部分，如果索引都在有效范围内，分切部分的长度就是索引的差值。例如， word[1:3] 的长度是2。<br>内置的函数 len() 用于返回一个字符串的长度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'supercalifragilisticexpialidocious'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</div><div class="line"><span class="number">34</span></div></pre></td></tr></table></figure><br>关于字符串格式化的信息请参考函数 str.format() 的表述。<br>当字符串和Unicode字符串是%运算符左边的操作数时，请参考旧的格式化操作调用方法。</p>
<h4 id="关于Unicode"><a href="#关于Unicode" class="headerlink" title="关于Unicode"></a>关于Unicode</h4><p>Python从2.0版开始全面支持 Unicode (请参考 <a href="http://www.unicode.org/" target="_blank" rel="external">http://www.unicode.org/</a> )。<br>Unicode为从古至今在脚本中用到的所有字符提供了一个次序列表。起初，只有256个可用的脚本字符次序。文本通常绑定到一个被映射到脚本字符次序的代码页中。这样很容易产生混淆，尤其在国际化的软件方面更是如此（通常记作 i18n —— ‘i’ + 18 个字符 + ‘n’）。Unicode通过为全部脚本定义一个代码页来解决这些问题。<br>如果您在字符串中包含特殊字符，您可以使用 Python Unicode-转义编码。如下例所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello\u0020World !'</span></div><div class="line"><span class="string">'Hello World !'</span></div></pre></td></tr></table></figure><br>转义次序 \u0020 用来标志在指定的位置插入次序值是 0x0020 的Unicode字符（空格符）。<br>其它的字符由它们各自的次序值直接解释，就像Unicode次序一样。如果您用到许多西方国家常用的标准拉丁-1编码文本串，你将会发现，较低次序的256个Unicode字符与Latin-1的256个字符一模一样。<br>除了这些标准编码，Python还提供了一整套方法用于在已知编码的基础上创建Unicode字符串。<br>通过使用专为字符串对像提供的 encode() 方法，可以将一个字符串转换为使用特定编码的字节序列，以编码的名称作为参数。首选小写的编码名称。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"Äpfel"</span>.encode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">b'\xc3\x84pfel'</span></div></pre></td></tr></table></figure><br>— 3.1.4. 列表<br>Python囊括了大量的复合数据类型，用于组织其它数值。最有用的是列表，即写在方括号之间、用逗号分隔开的数值列表。列表内的项目不必全是相同的类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="number">1234</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="number">1234</span>]</div></pre></td></tr></table></figure><br>同字符串索引一样，列表索引也是从 0 开始，列表也可以被分切，被串联，等等：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</div><div class="line"><span class="string">'spam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>]</div><div class="line"><span class="number">1234</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-2</span>]</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">-1</span>]</div><div class="line">[<span class="string">'eggs'</span>, <span class="number">100</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">2</span>] + [<span class="string">'bacon'</span>, <span class="number">2</span>*<span class="number">2</span>]</div><div class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>*a[:<span class="number">3</span>] + [<span class="string">'Boo!'</span>]</div><div class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="string">'Boo!'</span>]</div></pre></td></tr></table></figure><br>所有的分切操作返回一个包含有所需元素的新列表。如下例中，分切将返回列表 a 的一个拷贝：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:]</div><div class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="number">1234</span>]</div></pre></td></tr></table></figure><br>与字符串的一成不变有所不同的是，列表可以改变其中的个别元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="number">1234</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>] = a[<span class="number">2</span>] + <span class="number">23</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">123</span>, <span class="number">1234</span>]</div></pre></td></tr></table></figure><br>通过可以给分切部分赋值，可以改变列表的大小甚至清空列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 取代一些项目：</span></div><div class="line"><span class="meta">... </span>a[<span class="number">0</span>:<span class="number">2</span>] = [<span class="number">1</span>, <span class="number">12</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">12</span>, <span class="number">123</span>, <span class="number">1234</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 删除一些：</span></div><div class="line"><span class="meta">... </span>a[<span class="number">0</span>:<span class="number">2</span>] = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">123</span>, <span class="number">1234</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 插入一些：</span></div><div class="line"><span class="meta">... </span>a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="string">'bletch'</span>, <span class="string">'xyzzy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">123</span>, <span class="string">'bletch'</span>, <span class="string">'xyzzy'</span>, <span class="number">1234</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 在开头插入它本身（一个副本）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">0</span>] = a</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">123</span>, <span class="string">'bletch'</span>, <span class="string">'xyzzy'</span>, <span class="number">1234</span>, <span class="number">123</span>, <span class="string">'bletch'</span>, <span class="string">'xyzzy'</span>, <span class="number">1234</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 清除列表：把所有项目替换为空列表</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:] = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[]</div></pre></td></tr></table></figure><br>内置函数 len() 也能应用于列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure><br>也可以使用嵌套列表（在列表里创建其它列表），例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>q = [<span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="number">1</span>, q, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(p)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="number">1</span>]</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="number">1</span>][<span class="number">0</span>]</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure><br>您可以在列表的末尾添加项目：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="number">1</span>].append(<span class="string">'xtra'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p</div><div class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="string">'xtra'</span>], <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="string">'xtra'</span>]</div></pre></td></tr></table></figure><br>注意，在最后一个例子里，p[1] 和 q 实际上指向同一个对象！稍后我们将回到对象语法中继续讨论。</p>
<h4 id="迈出编程第一步"><a href="#迈出编程第一步" class="headerlink" title="迈出编程第一步"></a>迈出编程第一步</h4><p>当然，我们能使用Python完成比 2+2 更复杂的工作。在下例里，我们能写出一个初步的斐波纳契数列如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Fibonacci series: 斐波纳契数列</span></div><div class="line"><span class="meta">... </span><span class="comment"># 两个元素的总和确定了下一个数</span></div><div class="line"><span class="meta">... </span>a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> b &lt; <span class="number">10</span>:</div><div class="line"><span class="meta">... </span>    print(b)</div><div class="line"><span class="meta">... </span>    a, b = b, a+b</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure><br>这个例子介绍了几个新特征。</p>
<ul>
<li>第一行包含了一个复合赋值：变量 a 和 b 同时得到新值 0 和 1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</li>
<li>只要条件（这里是： b &lt; 10 ）为真，while循环将一直执行下去。在 Python 里，和C语言中一样，任何非零整数为真；零为假。限定条件可以是一个字符串或是一个列表，事实上可以是任何序列；任何非零长度的值都是真，空序列是假。在例子中用于测试的是一个简单的比较。标准的比较操作写法和C语言一样： &lt; （小于）， &gt; （大于） ， ==  （等于），   &lt;=  （小于等于）  ， &gt;= （大于等于）和 != （不等于）。</li>
<li>书写循环体时需要缩进：缩进是Python组合语句的主要方法。Python（暂）没有提供一个智能输入行的编辑功能，因此您必须在每一个缩进行键入一个制表符或空格符。在实践中您将会乐于使用一个文本编辑器，用以编写更复杂的Python程序；许多文本编辑器有自动缩进功能。当使用解释器交互输入一个复合语句时，语句块必须紧接一个空行表示该语句块结束（因为解释器不会知道您什么时候才会输入最后一行）。注意，同一语句块内的每一行都必须有相同的缩进量。<br>print() 函数输出表达式被赋予的值。它在处理复合表达式、浮点数和字符串方面，不同于仅仅输出的您想写出的表达式（就像我们较早前计算器的例子）。字符串的输出没有引号，各项之间插入空格，所以您可以很好地格式化输出，就像这样：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">256</span>*<span class="number">256</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'The value of i is'</span>, i)</div><div class="line">The value of i <span class="keyword">is</span> <span class="number">65536</span></div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
关键字end可以被用于防止输出新的一行，或者在输出的末尾添加不同的字符：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> b &lt; <span class="number">1000</span>:</div><div class="line"><span class="meta">... </span>    print(b, end=<span class="string">','</span>)</div><div class="line"><span class="meta">... </span>    a, b = b, a+b</div><div class="line">...</div><div class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt ui界面调用]]></title>
      <url>http://markma.tk/posts/QtStudy/Qt%E4%B8%AD%E7%95%8C%E9%9D%A2%E7%B1%BB%E5%90%8D%E7%9A%84%E4%BF%AE%E6%94%B9/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Qt 中如果想要使用多个已经写好的界面类，往往会发现界面类的名称要么是“MainWindow”，要么是“Widget”，或者是“Dialog”。那么重名的界面类在一起就会在所难免。或者你想修改界面类的名称。那么一定要切记不可直接修改界面类的名称。否则和容易出错。<br><a id="more"></a></p>
</blockquote>
<h2 id="Qt中界面类名的修改"><a href="#Qt中界面类名的修改" class="headerlink" title="Qt中界面类名的修改"></a>Qt中界面类名的修改</h2><p>正确的解决方法如下：</p>
<ul>
<li><p>1.修改.ui文件名称为xxxmainwindow.ui/xxxwidget.ui/xxxdialog.ui在工程树下右键修改即可。当然也可以为其他名字，总之要清晰明了有个性。</p>
</li>
<li><p>2.修改.h,.cpp名称与.ui文件名称对应：同样是在工程树下右键修改即可。</p>
</li>
<li><p>3.修改界面类名：右键类名，选择Refactor(重构器)-&gt;Rename Symbol under cursor(Ctrl+Shift+R)。</p>
</li>
</ul>
<p><img src="http://i.imgur.com/U5hMUJj.png" alt="" title="右键类名"></p>
<p>然后在此处即可方便的修改。然后类名即可全部被替换修改。</p>
<p><img src="http://i.imgur.com/XlzUuej.png" alt="" title="替换修改"></p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>将xxx.ui,xxx.h,xxx.cpp复制到工程目录下，在工程中主界面类的头文件包含头文件下面加入被调用界面类的声明，否则界面类无法调用。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;...&gt;</span></span></div><div class="line">...</div><div class="line"></div><div class="line">	<span class="keyword">class</span> xxx;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> QtStudy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HEXO+Github Create your Blog]]></title>
      <url>http://markma.tk/posts/Hexo/HEXO-Github-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转自<a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">《HEXO+Github,搭建属于自己的博客》</a><br><a id="more"></a></p>
</blockquote>
<h2 id="HEXO-Github-搭建属于自己的博客"><a href="#HEXO-Github-搭建属于自己的博客" class="headerlink" title="HEXO+Github,搭建属于自己的博客"></a>HEXO+Github,搭建属于自己的博客</h2><p>hexo是一款基于Node.js的静态博客框架,hexo github链接,这篇教程是针对与Mac的，参考链接，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。</p>
<p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客,貌似都是用hexo写得,我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>安装Node（必须）</p>
<p>作用：用来生成静态页面的</p>
<p>到Node.js官网下载相应平台的最新版本，一路安装即可。</p>
<p>安装Git（必须）</p>
<p>作用：把本地的hexo内容提交到github上去.</p>
<p>安装Xcode就自带有Git，我就不多说了。</p>
<p>申请GitHub（必须）</p>
<p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。</p>
<p>github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</p>
<p>正式安装Hexo<br>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>
<p>执行如下命令安装Hexo：</p>
<pre><code>sudo npm install -g hexo
</code></pre><p>初始化然后，执行init命令初始化hexo,命令：</p>
<pre><code>hexo init
</code></pre><p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>
<p>生成静态页面</p>
<pre><code>hexo generate（hexo g也可以）
</code></pre><p>本地启动</p>
<p>启动本地服务，进行文章预览调试，命令：</p>
<pre><code>hexo server
</code></pre><p>浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<h3 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h3><p>建立Repository</p>
<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>
<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>
<hr>
<pre><code>_config.yml    node_modules    public      source

db.json        package.json    scaffolds  themes
</code></pre><hr>
<p>现在我们需要_config.yml文件，来建立关联，命令：</p>
<pre><code>vim _config.yml
</code></pre><p>翻到最下面，改成我这样子的</p>
<pre><code>deploy:

     type: git

     repo: https://github.com/leopardpan/leopardpan.github.io.git

     branch: master
</code></pre><p>然后执行命令：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。</p>
<p>忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。</p>
<p>然后，执行配置命令：</p>
<pre><code>hexo deploy
</code></pre><p>然后再浏览器中输入<a href="https://username.github.io/" target="_blank" rel="external">https://username.github.io/</a>    就行了，我的github的账户叫markma,把这个改成你github的账户名就行了</p>
<h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>每次部署的步骤，可按以下三步来进行。</p>
<pre><code>hexo clean

hexo generate

hexo deploy
</code></pre><h3 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h3><pre><code>hexo new&quot;postName&quot; #新建文章

hexo new page&quot;pageName&quot; #新建页面

hexo generate #生成静态页面至public目录

hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）

hexo deploy #将.deploy目录部署到GitHub

hexo help # 查看帮助

hexo version #查看Hexo的版本
</code></pre><h3 id="报错总结"><a href="#报错总结" class="headerlink" title="报错总结"></a>报错总结</h3><h4 id="ERROR-Deployer-not-found-git-或者-ERROR-Deployer-not-found-github"><a href="#ERROR-Deployer-not-found-git-或者-ERROR-Deployer-not-found-github" class="headerlink" title="ERROR Deployer not found: git 或者 ERROR Deployer not found: github"></a>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</h4><p>解决方法： <code>npm install hexo-deployer-git --save</code></p>
<h4 id="ERROR-Process-failed-layout-DS-Store-那么进入主题里面layout和-partial目录下，使用删除命令："><a href="#ERROR-Process-failed-layout-DS-Store-那么进入主题里面layout和-partial目录下，使用删除命令：" class="headerlink" title="ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令："></a>ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：</h4><pre><code>rm-rf.DS_Store
</code></pre><h4 id="ERROR-Plugin-load-failed-hexo-server"><a href="#ERROR-Plugin-load-failed-hexo-server" class="headerlink" title="ERROR Plugin load failed: hexo-server"></a>ERROR Plugin load failed: hexo-server</h4><p>原因：</p>
<p>Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore.</p>
<p>解决方法，执行命令：</p>
<pre><code>sudo npm install hexo-server
</code></pre><h4 id="执行命令hexo-server，提示：Usage-hexo-…"><a href="#执行命令hexo-server，提示：Usage-hexo-…" class="headerlink" title="执行命令hexo server，提示：Usage: hexo …."></a>执行命令hexo server，提示：Usage: hexo ….</h4><p>原因：</p>
<p>我认为是没有生成本地服务</p>
<p>解决方法，执行命令：</p>
<pre><code>npm install hexo-server --save
</code></pre><h4 id="提示：hexo-server-0-1-2-node-modules-hexo-server"><a href="#提示：hexo-server-0-1-2-node-modules-hexo-server" class="headerlink" title="提示：hexo-server@0.1.2 node_modules/hexo-server"></a>提示：hexo-server@0.1.2 node_modules/hexo-server</h4><p>….</p>
<p>这个时候再执行：</p>
<p>hexo-server</p>
<p>得到:</p>
<pre><code>INFOHexo is running at http://0.0.0.0:4000/.PressCtrl+C to stop.
</code></pre><p>表示成功了</p>
<p>这个时候再点击 <a href="http://0.0.0.0:4000" target="_blank" rel="external">http://0.0.0.0:4000</a>    ，正常情况下应该是最原始的画面，但是我看到的是：</p>
<h4 id="白板和Cannot-GET-几个字"><a href="#白板和Cannot-GET-几个字" class="headerlink" title="白板和Cannot GET / 几个字"></a>白板和Cannot GET / 几个字</h4><p>原因：</p>
<p>由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p>
<pre><code>npm install hexo-renderer-ejs --save

npm install hexo-renderer-stylus --save

npm install hexo-renderer-marked --save
</code></pre><p>这个时候再重新生成静态文件，命令：</p>
<pre><code>hexo generate（或hexo g）
</code></pre><p>启动本地服务器：</p>
<pre><code>hexo server（或hexo s）
</code></pre><p>再，点击网址<a href="http://0.0.0.0:4000" target="_blank" rel="external">http://0.0.0.0:4000</a>    OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。</p>
<h3 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h3><p>这里有大量的主题列表使用方法里面</p>
<p>都有详细的介绍，我就不多说了。</p>
<p>我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，😄</p>
<p><a href="https://github.com/someus/huno" target="_blank" rel="external">huno</a>：是为Hexo编写的一个响应式的主题，该主题基于Uno。</p>
<p><a href="https://github.com/stiekel/hexo-theme-random" target="_blank" rel="external">random</a>：A hexo theme with random fullscreen background image</p>
<p><a href="https://github.com/markma/hexo-themes-cover" target="_blank" rel="external">Cover</a>- A chic theme with facebook-like cover photo</p>
<p><a href="https://github.com/henryhuang/oishi" target="_blank" rel="external">Oishi</a>- A white theme based on Landscape plus and Writing.</p>
<p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>- Responsive and simple style 优雅简洁响应式主题，我用得就是这个。</p>
<h4 id="修改头像"><a href="#修改头像" class="headerlink" title="修改头像"></a>修改头像</h4><p>我当前的路径/Users/leopard/blog/themes/yilia，ls 你可以看到</p>
<hr>
<p>Gruntfile.js    _config.yml     package.json</p>
<p>README.md        layout              source</p>
<hr>
<p>vim _config.yml 进去，找到 #你的头像url avatar: 后接一个URL就行了，头像就修改成功了</p>
<h4 id="附送随机设置背景网站unsplash"><a href="#附送随机设置背景网站unsplash" class="headerlink" title="附送随机设置背景网站unsplash"></a>附送随机设置背景网站<a href="https://source.unsplash.com/" target="_blank" rel="external">unsplash</a></h4><p>效果如下图：<img src="https://source.unsplash.com/random" alt="此图随机生成"></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://markma.tk/posts/Journal/hello-world/</url>
      <content type="html"><![CDATA[<p>2016年8月8日是一个值得纪念的日子，这一天我通过github pages成功的发出了我的第一篇博客。希望今后能够借助这个平台不断积累不断进步。 happying。。。^.^<br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> Journal </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
